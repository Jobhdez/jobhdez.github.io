---
layout: page
title: About
permalink: /about/
---

Hello, I am Job Hernandez and I am a programmer from Seattle, WA. Some of my interests include compilers, functional programming, and pure mathematics; in addition, I also enjoy thinking about operating systems and distributed systems.

### Software Projects
I write software as a hobby but for me programming is a serious hobby. Some of my projects include:

- [zettapy](https://github.com/jobhdez/zettapy), a compiler that lowers the core of an imperative language to an x86 AST.

#### Open Source contributions
- [coalton](https://github.com/coalton-lang/coalton), a statically typed programming language embedded in Common Lisp. Coalton is used in production for the development of a quantum compiler. My biggest contribution to Coalton and in open source in general is a library for automatic differentiation via dual numbers. You can see the original PR [here](https://github.com/coalton-lang/coalton/pull/890). It was merged by a core developer [here](https://github.com/coalton-lang/coalton/pull/926).

### Some fascinating quotes about programming

> I think that it’s extraordinarily important that we in computer science keep fun in computing. When it started out, it was an awful lot of fun. Of course, the paying customers got shafted every now and then, and after a while we began to take their complaints seriously. We began to feel as if we really were responsible for the successful, error-free perfect use of these machines. I don’t think we are. I think we’re responsible for stretching them, setting them off in new directions, and keeping fun in the house. I hope the field of computer science never loses its sense of fun. Above all, I hope we don’t become missionaries. Don’t feel as if you’re Bible salesmen. the world has too many of those already. What you know about computing other people will learn. Don’t feel as if the key to successful computing is only in your hands. What’s in your hands, I think and hope, is intelligence: the ability to see the machine as more than when you were first led up to it, that you can make it more. - Alan Perlis

>  Another way to show that Lisp was neater than Turing machines was to write a universal Lisp function and show that it is briefer and more comprehensible than the description of a universal Turing machine. This was the Lisp function eval..., which computes the value of a Lisp expression.... Writing eval required inventing a notation representing Lisp functions as Lisp data, and such a notation was devised for the purposes of the paper with no thought that it would be used to express Lisp programs in practice. - McCarthy

