I"6%<h1 id="mergesort-work">Mergesort work</h1>

<h2 id="how-does-mergesort-work">How does mergesort work?</h2>

<p>Mergesort is implemented using a technique called Divide and Conquer. In the mergesort algorithm you Divide the problem by creating two sub-arrays and you Conquer by sorting both of these sub-arrays with mergesort and, finally, you combine these two sorted sub-arrays. Divide and Conquer is recursive in nature.</p>

<p>Suppose you have two piles of cards both of which are sorted. In both piles of cards the smallest cards are on the top. The auxiliary procedure \(merge\) works by placing the smallest card from these two piles into the output pile until one pile is empty and then placing the remaining cards from the other pile on top of faced down.</p>

<h2 id="loop-invariant">Loop Invariant</h2>
<p>The loop invariant for the mergesort algorithm is the following.</p>

<p>At each iteration the sub-array \(A[\) p…k - 1 \(]\) consists of the \(k - p\) smallest elements from the sub-arrays \(L[\) 1 … n1 + 1 \(]\) and \(R[\) 1 … n2 + 1 \(]\). Furthermore, \(L[\) i \(]\) and \(R[\) i \(]\) are the smallest elements that have not been placed in the output pile.</p>

<h2 id="initialization">Initialization</h2>
<p>Prior to the first iteration the sub-array \(A[\) p … k-1 \(]\) contains the first \(k - p\) smallest elements of the sub-array \(L\) and \(R\). Since prior to the first iteration of the loop \(k = p = 0\) then it contains the 0th smallest elements – trivially, of course. And since \(i = j = 0\) the the \(L[\)i\(]\) and \(R[\)j\(]\) are the smallest elements – i.e., cards have not been placed in the output pile.</p>

<h2 id="maintenance">Maintenance</h2>
<p>Suppose that \(L[\) i \(]\) is less than or equal to \(R[\) j \(]\). Then this element is the smallest element of the two piles. We know that the sub-array \(A[\) p…k - 1 \(]\) contains the smallest \(k - p\) elements of the two sub-arrays. So when we \(L[\) i \(] = A[\) k \(]\) then \(A[\) p…k \(]\) consists of \(k - p + 1\) of the two sub-arrays. Incrementing \(i\) and \(k\) restablishes the loop invariant.</p>

<h2 id="termination">Termination</h2>
<p>By the loop invariant the sub-array \(A[\) p…k - 1 \(]\) which is  \(A[\) p … r \(]\) contains the smallest \(k - p\) elements of the two sub-arrays.</p>

<h1 id="code">Code</h1>

<p>Here is the implementation of the mergesort algorithm in CLRS:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="s">"""
    Divides the lst into two sublists and sorts them recursively and then
    merges the two sublists.
   
    @param lst: then given list that needs to be sorted
    @param start: the start of the first sublist 
    @param end: the end of the second sublist 
    @return: a sorted list

    """</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">merge_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>
        <span class="n">merge_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">merge</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">lst</span>
    
<span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">middle</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="s">"""
    Combines two sorted lists
    
    @param lst: the list to be sorted
    @param left: the left start of the first sublist
    @param middle: the mid point of the two sublists
    @param right: the end of the second sublist 
    @return: a sorted list
    """</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">middle</span>

    <span class="n">l_lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">r_lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n1</span><span class="p">):</span>
        <span class="n">l_lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n2</span><span class="p">):</span>
        <span class="n">r_lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>

    <span class="n">l_lst</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">inf</span>
    <span class="n">r_lst</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">inf</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l_lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">r_lst</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">lst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>

    
        
<span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">merge_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span></code></pre></figure>
:ET