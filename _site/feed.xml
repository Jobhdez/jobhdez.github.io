<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-09-21T17:56:22-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">(lambda () ‘(Jobs Blog))</title><subtitle>A technical blog about things I find interesting :)
</subtitle><author><name>Job Hernandez Lara</name><email>hj93@protonmail.com</email></author><entry><title type="html">Improving the performance of fmul with double-double arithmetic</title><link href="http://localhost:4000/2024/09/21/improving-performance-of-fmul-with-double-arithmetic.html" rel="alternate" type="text/html" title="Improving the performance of fmul with double-double arithmetic" /><published>2024-09-21T00:00:00-07:00</published><updated>2024-09-21T00:00:00-07:00</updated><id>http://localhost:4000/2024/09/21/improving-performance-of-fmul-with-double-arithmetic</id><content type="html" xml:base="http://localhost:4000/2024/09/21/improving-performance-of-fmul-with-double-arithmetic.html"><![CDATA[<p>Lately, I co-authored a PR that improved the performance of fmul by 7x by using double-double arithmetic. The following is a summary of my conversation with Tue Ly, the maintainer of LLVM libc.</p>

<p>If \(x_{1}\) and \(x_{2}\) are radix-2 precision-p floating point numbers, whose exponents \(e_{x1}\) and \(e_{x2}\) satisfy \(e_{x1} + e_{x2} &lt;  e_{min} + p - 1\) and if \(r\) is \(R(x_{1} x_{2})\) where R is a rounding function then \(t = x_{1}x_{2} - r\) is a radix 2 precision-p floating point number.</p>

<p>Using the <em>2MultFMA</em> algorithm we can compute \(t\):</p>

<p>\(r_{1} + r_{2} = x_{1} * x_{2}\) and \(r_{1} = RN(x_{1} * x_{2})\).</p>

<p>More specifically:</p>

<p>Ensure: \(r_{1} + r_{2} = x_{1}x_{2}\)</p>

<p>R1 &lt;-  \(RN(x_{1} * x_{2})\)</p>

<p>R2 &lt;- RN(x_{1} * x_{2} - r1)</p>

<p>Return (r1, r2)</p>

<p>So, the algorithm we have for <code class="language-plaintext highlighter-rouge">exact_mult</code> in C++ is essentially:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">prod_hi</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">);</span>
   <span class="n">prod_lo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">fma</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">prod_hi</span><span class="p">);</span> <span class="c1">// a * b - prod_hi exactly</span>
</code></pre></div></div>

<p>Or in sollya:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; prod_hi = round(a * b, D, RN);
&gt; prod_lo = a * b - prod_hi;
</code></pre></div></div>

<p>The product of <code class="language-plaintext highlighter-rouge">a * b</code> might not fit in a double precision, so <em>exact mult</em> will return <code class="language-plaintext highlighter-rouge">prod.hi</code> and <code class="language-plaintext highlighter-rouge">prod.lo</code> so that \(a * b = prod.hi + prod.lo\).</p>

<p>Example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; a = 2^8 + 1 + 2^-16 + 2^-31;
&gt; b = 2^15 - 1;
&gt; display = binary;
&gt; a * b;
1.000000001111110111111110111111111111111111111111111111_2 * 2^(23)
</code></pre></div></div>

<p>Basically round to the nearest 24 bits. That’s what happens when you round to <code class="language-plaintext highlighter-rouge">float</code>, i.e., <code class="language-plaintext highlighter-rouge">float</code> is 23 bit mantissa + 1 hidden bit.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.00000000111111011111111 | 0111111111111111111111111111111_2
</code></pre></div></div>

<p>And when we use round to nearest, the 24 bit precision will be?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.00000000111111011111111
</code></pre></div></div>

<p>Then we look at the rounding bit, the one right after the separator that was added which is <code class="language-plaintext highlighter-rouge">0</code> in this case so you will round down, and the answer is the same as the “integer part”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.00000000111111011111111
</code></pre></div></div>

<p>If it’s 1, we need to check the sticky bits. If the sticky bits are non-zero, we round up.</p>

<p>If the sticky bits are zero, we have a tie. And the default rounding mode is round-to-nearest, <em>tie-to-even</em> so you round up or down depending on which direction gives you an even number, i.e., the least-significant bit of the answer is 0.</p>

<p>Now can you try to round:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.000000001111110111111110111111111111111111111111111111_2
</code></pre></div></div>

<p>to the nearest 53-bit?</p>

<p><code class="language-plaintext highlighter-rouge">1.0000000011111101111111101111111111111111111111111111|11_2</code></p>

<p>All the bits on the left of <code class="language-plaintext highlighter-rouge">|</code> are integer part, the bit right on the right of <code class="language-plaintext highlighter-rouge">| </code> is the rounding bit
the remaining bits on the right of rounding bit are sticky bits.</p>

<p>When we round up, we simply increase the “integer part” by 1 and the integer part above is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.0000000011111101111111101111111111111111111111111111
</code></pre></div></div>

<p>and if you add the whole thing by 1 lowest bit, it will be?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.0000000011111101111111101111111111111111111111111111
-&gt;
1.0000000011111101111111110000000000000000000000000000
</code></pre></div></div>

<p>and that will be the bits when we do <code class="language-plaintext highlighter-rouge">round(a*b, D, RN)</code></p>

<p>Which is the same as <code class="language-plaintext highlighter-rouge">prod.hi</code> now, your next step is to round that (<code class="language-plaintext highlighter-rouge">prod.hi</code>) to 24 bits.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.0000000011111101111111110000000000000000000000000000
</code></pre></div></div>

<p>to nearest 24 bits, following the same process</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; round(a * b, SG, RN); // round to 24-bit precision
&gt; round(a * b, D, RN); // round to 53-bit precision
</code></pre></div></div>

<p>So the rounding process, should always start with picking the “integral part”</p>

<p>so the exact mult will return prod.hi and prod.lo so that \(a * b = prod.hi + prod.lo\); for example,</p>

<p>we can actually see it in action with Sollya:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; a = 2^52 + 1; b = 2^52 + 1;
&gt; prod_hi = round(a*b, D, RN); prod_lo = a*b - prod_hi;
&gt; a \* b;
&gt; prod_hi;
&gt; prod_lo;
&gt; prod_hi + prod_lo;
</code></pre></div></div>

<p>do you see that</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prod_hi = round(a*b, D, RN);
</code></pre></div></div>

<p>so we will round that bit string to 24 bits:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.0000000011111101111111110000000000000000000000000000

1.00000000111111011111111|10000000000000000000000000000
</code></pre></div></div>

<p>so we need to round to even since the round bit is non zero and the sticky bits is 0. Round to even means that the last significant value is 0.</p>

<p>So first
first we get the leading 24 bit (“integer part”):</p>

<p><code class="language-plaintext highlighter-rouge">1.00000000111111011111111</code></p>

<p>then we look at the rounding bit, which is?
The 1 after the bar and the sticky bits are?</p>

<p>The 0s after that</p>

<p>So you round up or down depending on which direction gives you an even number, i.e., the least-significant bit of the answer is 0.</p>

<p>In this case, up or down (i.e. keep the integer part) will give you even bits?</p>

<p>So, we have the bits,</p>

<p><code class="language-plaintext highlighter-rouge">1.00000000111111011111111</code></p>

<p>Round down:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.00000000111111011111111 | 10000000000 -&gt; 1.00000000111111011111111
</code></pre></div></div>

<p>Round up:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.00000000111111011111111 | 10000000000 -&gt; 1.00000000111111011111111 + 1 ULP
</code></pre></div></div>

<p>but the least sig val needs to be a 0 right?
So the round up it is:</p>

<p>1.00000000111111100000000</p>

<p>So, as I said above, the algorithm we have for <code class="language-plaintext highlighter-rouge">exact_mult</code> in C++ is essentially:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   prod_hi = static_cast&lt;double&gt;(a * b);
   prod_lo = std::fma(a, b, -prod_hi); // a * b - prod_hi exactly
</code></pre></div></div>

<p>Or in Sollya:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; prod_hi = round(a * b, D, RN);
&gt; prod_lo = a * b - prod_hi; // Notice that I don't need to round here, because it's exact in double precision

&gt; prod_hi;
1.000000001111110111111111_2 * 2^(23)

&gt; prod_hi + prod_lo;
1.000000001111110111111110111111111111111111111111111111_2 * 2^(23)
</code></pre></div></div>

<p>That will calculate the exact result which is <code class="language-plaintext highlighter-rouge">a*b</code>.</p>

<p>In C++ <code class="language-plaintext highlighter-rouge">prod_hi + prod_lo</code> will round the exact result to <code class="language-plaintext highlighter-rouge">double</code> which in sollya you do by:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>round(prod_hi+prod_lo, D, RN);
1.000000001111110111111111_2 * 2^(23)
</code></pre></div></div>

<p>Round to single precision:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; round(val, SG, RN);
1.000000001111111_2 * 2^(23)
&gt; round(a*b, SG, RN);
1.00000000111111011111111_2 * 2^(23)
</code></pre></div></div>

<p>so whats happening here is that we are rounding one extra time.</p>

<p>And that’s why this type of errors is called <code class="language-plaintext highlighter-rouge">double-rounding errors</code>.</p>

<p>The fix of the double rounding errors is handling <code class="language-plaintext highlighter-rouge">prod.lo</code>.</p>

<p>So now, we will handle 3 cases: <code class="language-plaintext highlighter-rouge">lo &gt; 0, lo = 0, lo &lt; 0</code>
Ok, lets start with \(lo = 0\). When \(lo = 0\) we have \(hi + lo = hi\).</p>

<p>Ok, so now lets say we have <code class="language-plaintext highlighter-rouge">hi + lo</code>
both of which are double precision. What does this mean?</p>

<p>When \(lo = 0\) — i.e., \(hi + lo = hi\) —
means that \(result = prod_hi\) is enough to get correctly rounding to single precision.</p>

<p>On the other hand when \(lo &lt; 0\), let’s compare <code class="language-plaintext highlighter-rouge">round(hi + lo, SG, RN)</code> and <code class="language-plaintext highlighter-rouge">round(hi, SG, RN)</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>​​&gt; hi = 1 + 2^-23 + 2^-24;
&gt; lo = -2^-55;
&gt; hi = 1 + 2^-23 + 2^-24;
&gt; lo = -2^-55;
&gt; hi;
1.000000000000000000000011_2
&gt; lo;
-1_2 * 2^(-55)

</code></pre></div></div>

<p>Now, let’s do the rounding — i.e., <code class="language-plaintext highlighter-rouge">round(hi + lo, SG, RN)</code> and <code class="language-plaintext highlighter-rouge">round(hi, SG, RN)</code> —</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; hi = 1 + 2^-23 + 2^-24;
&gt; lo = -2^-55;
&gt; round(hi + lo, SG, RN);
1.00000000000000000000001_2
&gt; round(hi, SG, RN);
1.0000000000000000000001_2
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">round(hi, SG, RN)</code> did round up, but actually it needs to round down to match <code class="language-plaintext highlighter-rouge">round(hi + lo, SG, RN)</code>, the correct result</p>

<p>so, in order for <code class="language-plaintext highlighter-rouge">round(hi, SG, RN)</code> to round up, we must have:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- rb in hi is 1
and at least
1) lsb in hi is 1, or
2) remaining sticky bits in hi is &gt; 0
</code></pre></div></div>

<p>so for the default rounding modes, after getting (truncating) the “integer part”, we will round up if:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rb &amp;&amp; (lsb || (r != 0))
</code></pre></div></div>

<p>where</p>

<p><code class="language-plaintext highlighter-rouge">rb</code> is the rounding bit; <code class="language-plaintext highlighter-rouge">lsb</code> is the least significant bit (of the integer part) and <code class="language-plaintext highlighter-rouge">r != 0</code> is just <code class="language-plaintext highlighter-rouge">sticky bits</code> are positive.</p>

<p>So, in order for <code class="language-plaintext highlighter-rouge">round(hi, SG, RN)</code> to round up, we must have:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- rb in hi is 1
and at least
1) lsb in hi is 1, or
2) remaining sticky bits in hi is &gt; 0
</code></pre></div></div>

<p>now, if it is case 2: <code class="language-plaintext highlighter-rouge">remaining sticky bits in hi is &gt; 0</code>
because <code class="language-plaintext highlighter-rouge">|lo| &lt;= ulp(hi) / 2</code>,
<code class="language-plaintext highlighter-rouge">remaining sticky bits in (hi + lo)</code> is still &gt; 0</p>

<p>so the rounding action we take with respect to <code class="language-plaintext highlighter-rouge">hi + lo</code> is still round up,</p>

<p>i.e. <code class="language-plaintext highlighter-rouge">round(hi, SG, RN) = round(hi + lo, SG, RN)</code> in that case.
Right? Yes</p>

<p>so now, let consider the case <code class="language-plaintext highlighter-rouge">round(hi, SG, RN)</code> is round-up because:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- rb is 1,
- lsb is 1,
- but sticky bits of hi is 0
</code></pre></div></div>

<p>(which is exactly what we have with <code class="language-plaintext highlighter-rouge">hi = 1 + 2^-23 + 2^-24</code>)
so now, because <code class="language-plaintext highlighter-rouge">lo &lt; 0</code>, if you look at the exact bits of <code class="language-plaintext highlighter-rouge">hi + lo</code>, you will see that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- lsb is still 1
- rb is 0
- sticky bits of hi + lo are &gt; 0
</code></pre></div></div>

<p>so because <code class="language-plaintext highlighter-rouge">rb</code> of <code class="language-plaintext highlighter-rouge">hi + lo</code> is 0, the correct rounding of <code class="language-plaintext highlighter-rouge">hi + lo</code> is round down, not round up</p>

<p>so to highlight it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; hi;
1.000000000000000000000011_2
&gt; hi + lo;
1.0000000000000000000000101111111111111111111111111111111_2
</code></pre></div></div>

<p>and lets highlight rounding bit with <code class="language-plaintext highlighter-rouge">[ ]</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; hi;
1.00000000000000000000001[1]_2
&gt; hi + lo;
1.00000000000000000000001[0]1111111111111111111111111111111_2
</code></pre></div></div>

<p>so in the first case, the logic is something like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// At this point, hi is not 0, and lo is smaller than hi.
FPBits&lt;double&gt; hi_bits(hi), lo_bits(lo);
if (lo_bits.sign() != hi_bits.sign()) {
  // Check if sticky bit of hi are all 0
  constexpr uint64_t STICKY_MASK = 0xFFF'FFFF;  // Lower (52 - 23 - 1 = 28 bits)
  uint64_t sticky_bits = (hi_bits.uintval() &amp; STICKY_MASK);
  uint64_t result_bits = (sticky_bits == 0) ? (hi_bits.uintval() - 1) : hi_bits.uintval();
  double result = FPBits&lt;double&gt;(result_bits).get_val();
  return static_cast&lt;float&gt;(result);
}
</code></pre></div></div>]]></content><author><name>Job Hernandez Lara</name></author><category term="computer-science" /><category term="floating-point-arithmetic" /><category term="llvm" /><summary type="html"><![CDATA[Lately, I co-authored a PR that improved the performance of fmul by 7x by using double-double arithmetic. The following is a summary of my conversation with Tue Ly, the maintainer of LLVM libc.]]></summary></entry><entry><title type="html">Compiling core programming constructs</title><link href="http://localhost:4000/2024/06/12/compiling-core-programming-constructs.html" rel="alternate" type="text/html" title="Compiling core programming constructs" /><published>2024-06-12T00:00:00-07:00</published><updated>2024-06-12T00:00:00-07:00</updated><id>http://localhost:4000/2024/06/12/compiling-core-programming-constructs</id><content type="html" xml:base="http://localhost:4000/2024/06/12/compiling-core-programming-constructs.html"><![CDATA[<p>I would like to share a bit about compiling core programming constructs; recently, I implemented a compiler in Haskell that lowered core constructs such as tuples, if expressions, loops, comparison operators (i.e., &lt;, &gt;) and assignment and simple arithmetic.</p>

<p>Compilers have been traditionally broken up into three main components, namely, the frontend, optimizer, and the backend; nevertheless, in my project, I did not implemented an optimizer.</p>

<h3 id="front-end">Front-end</h3>

<p>The purpose of the front-end is to create an intermediate representation. A compiler front-end consists of lexical analysis whereby the source program is broken up into tokens, the parse tree whereby the tokens get composed into a tree based on the grammar of the language; for example, the tokens of my small language are the following:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">token</span>
<span class="kr">if</span>         <span class="p">{</span> <span class="kt">TokenIf</span> <span class="p">}</span>
<span class="kr">let</span>        <span class="p">{</span> <span class="kt">TokenLet</span> <span class="p">}</span>
<span class="kr">then</span>       <span class="p">{</span> <span class="kt">TokenThen</span> <span class="p">}</span>
<span class="kr">else</span>       <span class="p">{</span> <span class="kt">TokenElse</span> <span class="p">}</span>
<span class="n">while</span>      <span class="p">{</span> <span class="kt">TokenWhile</span> <span class="p">}</span>
<span class="n">var</span>        <span class="p">{</span> <span class="kt">TokenVar</span> <span class="o">$$</span> <span class="p">}</span>
<span class="n">int</span>        <span class="p">{</span> <span class="kt">TokenInt</span> <span class="o">$$</span> <span class="p">}</span>
<span class="n">print</span>      <span class="p">{</span> <span class="kt">TokenPrint</span> <span class="p">}</span>
<span class="n">true</span>       <span class="p">{</span> <span class="kt">TokenTrue</span> <span class="o">$$</span><span class="p">}</span>
<span class="n">false</span>      <span class="p">{</span> <span class="kt">TokenFalse</span> <span class="o">$$</span><span class="p">}</span>
<span class="n">defun</span>      <span class="p">{</span> <span class="kt">TokenDefun</span> <span class="p">}</span>
<span class="sc">'='</span>        <span class="p">{</span> <span class="kt">TokenEq</span> <span class="p">}</span>
<span class="sc">'+'</span>        <span class="p">{</span> <span class="kt">TokenPlus</span> <span class="p">}</span>
<span class="sc">'-'</span>        <span class="p">{</span> <span class="kt">TokenMinus</span> <span class="p">}</span>
<span class="sc">'{'</span>        <span class="p">{</span> <span class="kt">TokenCurlyL</span> <span class="p">}</span>
<span class="sc">'}'</span>        <span class="p">{</span> <span class="kt">TokenCurlyR</span> <span class="p">}</span>
<span class="sc">'('</span>        <span class="p">{</span> <span class="kt">TokenOP</span> <span class="p">}</span>
<span class="sc">')'</span>        <span class="p">{</span> <span class="kt">TokenCP</span> <span class="p">}</span>
<span class="sc">']'</span>        <span class="p">{</span> <span class="kt">TokenSqBR</span> <span class="p">}</span>
<span class="sc">'['</span>        <span class="p">{</span> <span class="kt">TokenSqBL</span> <span class="p">}</span>
<span class="sc">'&lt;'</span>        <span class="p">{</span> <span class="kt">TokenLess</span> <span class="p">}</span>
<span class="sc">'&gt;'</span>        <span class="p">{</span> <span class="kt">TokenGreater</span> <span class="p">}</span>
<span class="sc">':'</span>        <span class="p">{</span> <span class="kt">TokenColon</span> <span class="p">}</span>
<span class="sc">';'</span>        <span class="p">{</span> <span class="kt">TokenSemicolon</span> <span class="p">}</span>
<span class="o">%%</span>
</code></pre></div></div>

<p>and this is the grammar, which gives the semantics:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Exp</span> <span class="o">:</span> <span class="n">var</span>  <span class="p">{</span> <span class="kt">Var</span> <span class="o">$</span><span class="mi">1</span> <span class="p">}</span>
<span class="o">|</span> <span class="kr">let</span> <span class="n">var</span> <span class="sc">'='</span> <span class="kt">Exp</span> <span class="sc">';'</span> <span class="p">{</span> <span class="kt">Let</span> <span class="o">$</span><span class="mi">2</span> <span class="o">$</span><span class="mi">4</span> <span class="p">}</span>
<span class="o">|</span> <span class="kt">Exp</span> <span class="sc">'+'</span> <span class="kt">Exp</span> <span class="sc">';'</span> <span class="p">{</span> <span class="kt">Plus</span> <span class="o">$</span><span class="mi">1</span> <span class="o">$</span><span class="mi">3</span> <span class="p">}</span>
<span class="o">|</span> <span class="kt">Exp</span> <span class="sc">'-'</span> <span class="kt">Exp</span> <span class="sc">';'</span> <span class="p">{</span> <span class="kt">Minus</span> <span class="o">$</span><span class="mi">1</span> <span class="o">$</span><span class="mi">3</span> <span class="p">}</span>
<span class="o">|</span> <span class="kt">Exp</span> <span class="sc">'&lt;'</span> <span class="kt">Exp</span> <span class="sc">';'</span>   <span class="p">{</span> <span class="kt">LessThn</span> <span class="o">$</span><span class="mi">1</span> <span class="o">$</span><span class="mi">3</span> <span class="p">}</span>
<span class="o">|</span> <span class="kt">Exp</span> <span class="sc">'&gt;'</span> <span class="kt">Exp</span> <span class="sc">';'</span> <span class="p">{</span> <span class="kt">GreaterThn</span> <span class="o">$</span><span class="mi">1</span> <span class="o">$</span><span class="mi">3</span> <span class="p">}</span>
<span class="o">|</span> <span class="kr">if</span> <span class="kt">Exp</span> <span class="kr">then</span> <span class="kt">Exp</span> <span class="kr">else</span> <span class="kt">Exp</span> <span class="sc">';'</span> <span class="p">{</span> <span class="kt">IfExp</span> <span class="o">$</span><span class="mi">2</span> <span class="o">$</span><span class="mi">4</span> <span class="o">$</span><span class="mi">6</span> <span class="p">}</span>
<span class="o">|</span> <span class="n">true</span> <span class="p">{</span> <span class="kt">Bool</span> <span class="o">$</span><span class="mi">1</span> <span class="p">}</span>
<span class="o">|</span> <span class="n">false</span> <span class="p">{</span> <span class="kt">Bool</span> <span class="o">$</span><span class="mi">1</span> <span class="p">}</span>
<span class="o">|</span> <span class="n">print</span> <span class="sc">'('</span> <span class="kt">Exp</span> <span class="sc">')'</span> <span class="sc">';'</span> <span class="p">{</span> <span class="kt">PrintExp</span> <span class="o">$</span><span class="mi">3</span> <span class="p">}</span>
<span class="o">|</span> <span class="kt">Exp</span> <span class="sc">';'</span> <span class="kt">Exp</span>  <span class="p">{</span> <span class="kt">Exps</span> <span class="o">$</span><span class="mi">1</span> <span class="o">$</span><span class="mi">3</span> <span class="p">}</span>
<span class="o">|</span> <span class="n">while</span> <span class="kt">Exp</span> <span class="sc">':'</span> <span class="kt">Exp</span>  <span class="p">{</span> <span class="kt">While</span> <span class="o">$</span><span class="mi">2</span> <span class="o">$</span><span class="mi">4</span> <span class="p">}</span>
<span class="o">|</span> <span class="n">defun</span> <span class="kt">Exp</span> <span class="sc">'('</span> <span class="kt">Exp</span> <span class="sc">')'</span> <span class="sc">'{'</span> <span class="kt">Exp</span> <span class="sc">'}'</span>   <span class="p">{</span> <span class="kt">DefunExp</span> <span class="o">$</span><span class="mi">2</span> <span class="o">$</span><span class="mi">4</span> <span class="o">$</span><span class="mi">7</span> <span class="p">}</span> 
<span class="o">|</span> <span class="sc">'('</span> <span class="kt">Exp</span> <span class="sc">')'</span>   <span class="p">{</span> <span class="kt">TupleExp</span> <span class="o">$</span><span class="mi">2</span> <span class="p">}</span>
<span class="o">|</span> <span class="kt">Exp</span> <span class="sc">'['</span> <span class="n">int</span> <span class="sc">']'</span>   <span class="p">{</span> <span class="kt">TupleIndex</span> <span class="o">$</span><span class="mi">1</span> <span class="o">$</span><span class="mi">3</span> <span class="p">}</span>
<span class="o">|</span> <span class="n">int</span>  <span class="p">{</span> <span class="kt">Int</span> <span class="o">$</span><span class="mi">1</span> <span class="p">}</span>
<span class="o">|</span> <span class="sc">'-'</span> <span class="n">int</span> <span class="p">{</span> <span class="kt">Negative</span> <span class="o">$</span><span class="mi">2</span> <span class="p">}</span>
<span class="p">{</span>
</code></pre></div></div>

<p>Consider the expression:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"let x = 0;; while x &lt; 4;: if x &lt; 5; then print(x);; let x = x + 1;; else print(3);;"
</code></pre></div></div>

<p>The lexer, which breaks programs such as this into tokens would produce the following tokens:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
    <span class="kt">TokenLet</span><span class="p">,</span>
    <span class="kt">TokenVar</span> <span class="s">"x"</span><span class="p">,</span>
    <span class="kt">TokenEq</span><span class="p">,</span>
    <span class="kt">TokenInt</span> <span class="mi">0</span><span class="p">,</span>
    <span class="kt">TokenSemicolon</span><span class="p">,</span>
    <span class="kt">TokenSemicolon</span><span class="p">,</span>
    <span class="kt">TokenWhile</span><span class="p">,</span>
    <span class="kt">TokenVar</span> <span class="s">"x"</span><span class="p">,</span>
    <span class="kt">TokenLess</span><span class="p">,</span>
    <span class="kt">TokenInt</span> <span class="mi">4</span><span class="p">,</span>
    <span class="kt">TokenSemicolon</span><span class="p">,</span>
    <span class="kt">TokenColon</span><span class="p">,</span>
    <span class="kt">TokenIf</span><span class="p">,</span>
    <span class="kt">TokenVar</span> <span class="s">"x"</span><span class="p">,</span>
    <span class="kt">TokenLess</span><span class="p">,</span>
    <span class="kt">TokenInt</span> <span class="mi">5</span><span class="p">,</span>
    <span class="kt">TokenSemicolon</span><span class="p">,</span>
    <span class="kt">TokenThen</span><span class="p">,</span>
    <span class="kt">TokenPrint</span><span class="p">,</span>
    <span class="kt">TokenOP</span><span class="p">,</span>
    <span class="kt">TokenVar</span> <span class="s">"x"</span><span class="p">,</span>
    <span class="kt">TokenCP</span><span class="p">,</span>
    <span class="kt">TokenSemicolon</span><span class="p">,</span>
    <span class="kt">TokenSemicolon</span><span class="p">,</span>
    <span class="kt">TokenLet</span><span class="p">,</span>
    <span class="kt">TokenVar</span> <span class="s">"x"</span><span class="p">,</span>
    <span class="kt">TokenEq</span><span class="p">,</span>
    <span class="kt">TokenVar</span> <span class="s">"x"</span><span class="p">,</span>
    <span class="kt">TokenPlus</span><span class="p">,</span>
    <span class="kt">TokenInt</span> <span class="mi">1</span><span class="p">,</span>
    <span class="kt">TokenSemicolon</span><span class="p">,</span>
    <span class="kt">TokenSemicolon</span><span class="p">,</span>
    <span class="kt">TokenElse</span><span class="p">,</span>
    <span class="kt">TokenPrint</span><span class="p">,</span>
    <span class="kt">TokenOP</span><span class="p">,</span>
    <span class="kt">TokenInt</span> <span class="mi">3</span><span class="p">,</span>
    <span class="kt">TokenCP</span><span class="p">,</span>
    <span class="kt">TokenSemicolon</span><span class="p">,</span>
    <span class="kt">TokenSemicolon</span>
<span class="p">]</span>
</code></pre></div></div>

<p>and using the above grammar, the parser generator creates the following abstract syntax tree:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Exps</span> <span class="p">(</span><span class="kt">Let</span> <span class="s">"x"</span> <span class="p">(</span><span class="kt">Int</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="kt">While</span> <span class="p">(</span><span class="kt">LessThn</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">"x"</span><span class="p">)</span> <span class="p">(</span><span class="kt">Int</span> <span class="mi">4</span><span class="p">))</span> <span class="p">(</span><span class="kt">IfExp</span> <span class="p">(</span><span class="kt">LessThn</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">"x"</span><span class="p">)</span> <span class="p">(</span><span class="kt">Int</span> <span class="mi">5</span><span class="p">))</span> <span class="p">(</span><span class="kt">Exps</span> <span class="p">(</span><span class="kt">PrintExp</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">"x"</span><span class="p">))</span> <span class="p">(</span><span class="kt">Let</span> <span class="s">"x"</span> <span class="p">(</span><span class="kt">Plus</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">"x"</span><span class="p">)</span> <span class="p">(</span><span class="kt">Int</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">(</span><span class="kt">PrintExp</span> <span class="p">(</span><span class="kt">Int</span> <span class="mi">3</span><span class="p">))))</span>
</code></pre></div></div>

<p>In other words, one of the main purposes of the compiler’s front-end is to translate concrete syntax – i.e., the text of the program – to an abstract syntax tree which is a representation used inside the compiler.</p>

<p>After generating the parse tree, the other purpose of the front-end is to generate a machine independent intermediate representation; this could be a graph or an abstract syntax tree.</p>

<p>In my compiler, I used an intermediate language called <em>A Normal Form</em> which lowers the AST generated by the parser to a language consisting of only atomic and complex expressions. Atomic expressions are expressions that have no side effects and can essentially be part of assembly instructions.</p>

<p>For example, consider the AST generated for this expression:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x = 4 + -3
</code></pre></div></div>

<p>The <em>A Normal Form</em> generated for this is the following:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">SeqMon</span> <span class="p">(</span><span class="kt">MonLet</span> <span class="s">"temp_0"</span> <span class="p">(</span><span class="kt">MonNegative</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="kt">MonLet</span> <span class="s">"x"</span> <span class="p">(</span><span class="kt">MonPlus</span> <span class="p">(</span><span class="kt">AtmInt</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="kt">AtmVar</span> <span class="s">"temp_0"</span><span class="p">)))</span>
</code></pre></div></div>

<p>But a more interesting problem from an implementation side is generating the <em>A Normal Form</em> for the following expression:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if if true then true else false; then 1 else 2;
</code></pre></div></div>

<p>Given that the condition of the <em>if</em> expression can be another <em>if</em> expression you need a cool recursive algorithm:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">toMon</span> <span class="p">(</span><span class="kt">IfExp</span> <span class="p">(</span><span class="kt">IfExp</span> <span class="n">cnd</span> <span class="n">thn</span> <span class="n">els</span><span class="p">)</span> <span class="n">thn2</span> <span class="n">els2</span><span class="p">)</span> <span class="n">counter</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="n">tmpname</span> <span class="o">=</span> <span class="s">"temp_"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">counter</span> <span class="kr">in</span>
    <span class="kr">let</span> <span class="n">counter2</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">in</span>
      <span class="kr">let</span> <span class="n">tmpname2</span> <span class="o">=</span> <span class="s">"temp_"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">counter2</span> <span class="kr">in</span>
        <span class="kr">let</span> <span class="n">counter3</span> <span class="o">=</span> <span class="n">counter2</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">in</span>
          <span class="kr">let</span> <span class="n">counter4</span> <span class="o">=</span> <span class="n">counter3</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">in</span>
            <span class="kt">MonLstSeq</span> <span class="p">(</span><span class="kt">MonLet</span> <span class="n">tmpname</span> <span class="p">(</span><span class="n">toMon</span> <span class="n">cnd</span> <span class="n">counter3</span><span class="p">))</span> <span class="p">(</span><span class="kt">MonLet</span> <span class="n">tmpname2</span> <span class="p">(</span><span class="n">toMon</span> <span class="p">(</span><span class="kt">IfExp</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">tmpname</span><span class="p">)</span> <span class="n">thn</span> <span class="n">els</span><span class="p">)</span> <span class="n">counter4</span><span class="p">))</span> <span class="p">(</span><span class="n">toMon</span> <span class="p">(</span><span class="kt">IfExp</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">tmpname2</span><span class="p">)</span> <span class="n">thn2</span> <span class="n">els2</span><span class="p">)</span> <span class="n">counter4</span><span class="p">)</span>
</code></pre></div></div>

<p>which generates the following A Normal Form for the <em>if</em> expression above</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">MonLstSeq</span> <span class="p">(</span><span class="kt">MonLet</span> <span class="s">"temp_0"</span> <span class="p">(</span><span class="kt">AtmVar</span> <span class="s">"true"</span><span class="p">))</span> <span class="p">(</span><span class="kt">MonLet</span> <span class="s">"temp_1"</span> <span class="p">(</span><span class="kt">MonIf</span> <span class="p">(</span><span class="kt">AtmVar</span> <span class="s">"temp_0"</span><span class="p">)</span> <span class="p">(</span><span class="kt">AtmVar</span> <span class="s">"true"</span><span class="p">)</span> <span class="p">(</span><span class="kt">AtmVar</span> <span class="s">"false"</span><span class="p">)))</span> <span class="p">(</span><span class="kt">MonIf</span> <span class="p">(</span><span class="kt">AtmVar</span> <span class="s">"temp_1"</span><span class="p">)</span> <span class="p">(</span><span class="kt">AtmInt</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">AtmInt</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div></div>

<h4 id="directed-acyclic-graph">Directed Acyclic Graph</h4>

<p>The ANF that you see above is an abstract syntax tree but instead of an AST you can lower the AST of the parse tree to a directed acyclic graph (DAG). A DAG is similar to a tree so it can be constructed similary and, although I have not implemented a DAG, the way to do it is while traversing the AST of the parse tree, you can check whether a node has been constructed in the DAG. If it is you can just return that. The advantage of DAGs over ASTs is that you do not create a node for identical sub expressions and as a result you can generate assembly consisting of less instructions.</p>

<h3 id="back-end">Back-end</h3>

<p>Lets continue with the above example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x = 0;; while x &lt; 4;: if x &lt; 5; then print(x);; let x = x + 1;; else print(3);;
</code></pre></div></div>

<p>The ANF generated for the above example is this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SeqMon (MonLet "x" (AtmInt 0)) (MonWhile (MonLessThn (AtmVar "x") (AtmInt 4)) (MonIf (MonLessThn (AtmVar "x") (AtmInt 5)) (SeqMon (MonPrint (AtmVar "x")) (MonLet "x" (MonPlus (AtmVar "x") (AtmInt 1)))) (MonPrint (AtmInt 3))))
</code></pre></div></div>

<p>After the ANF pass, the instruction selection pass is next. The purpose of the instructor selector is to <em>select</em> the appropriate x86 instructions. The intermediate language for this will be <em>three address code</em> which models assembly instructions such as:</p>

<pre><code class="language-x86asm">movq $1, %rax
</code></pre>

<p>As you can see, the instruction above has three components.</p>

<p>The instruction selection pass generates the following for the running example:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
    <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"x"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"whiletest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"whiletestlabel"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">":"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"cmpq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="mi">4</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"x"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"jge"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"exit"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"jmp"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"iftest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"iftest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"iftestlabel"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"cmpq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="mi">5</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"x"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"jmp"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"block_0"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"je"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"block_1"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"block_0"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"blkdummy"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"x"</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="s">"%rdi"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"print"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"incq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"x"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"jmp"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"whiletest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"thanks"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"block_1"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="mi">3</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="s">"%rdi"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"print"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"jmp"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"whiletest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"thanks"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"exit"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"retq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">)</span>
<span class="p">]</span>

</code></pre></div></div>

<p>The relevant code that generates this is as follows:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">toSelect</span> <span class="p">(</span><span class="kt">MonLet</span> <span class="n">var</span> <span class="p">(</span><span class="kt">AtmInt</span> <span class="n">n</span><span class="p">))</span> <span class="o">=</span>
  <span class="p">[(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">n</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">var</span><span class="p">)]</span>

<span class="n">toSelect</span> <span class="p">(</span><span class="kt">MonWhile</span> <span class="n">cnd</span> <span class="n">exps</span><span class="p">)</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="n">selectcnd</span> <span class="o">=</span> <span class="n">toSelect</span> <span class="n">cnd</span> <span class="kr">in</span>
    <span class="kr">let</span> <span class="n">selectexps</span> <span class="o">=</span> <span class="n">toSelect</span> <span class="n">exps</span> <span class="kr">in</span>
      <span class="p">[(</span><span class="s">"whiletest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">)]</span> <span class="o">++</span> <span class="n">selectcnd</span> <span class="o">++</span> <span class="p">[(</span><span class="s">"jge"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"exit"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span> <span class="p">(</span><span class="s">"jmp"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"loop"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">)]</span><span class="o">++</span><span class="p">[(</span><span class="s">"loop"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"tst"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"tstdummy"</span><span class="p">)]</span> <span class="o">++</span> <span class="n">selectexps</span> <span class="o">++</span> <span class="p">[(</span><span class="s">"jmp"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"whiletest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">)]</span> <span class="o">++</span> <span class="p">[(</span><span class="s">"exit"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"retq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">)]</span>

<span class="n">toSelect</span> <span class="p">(</span><span class="kt">MonLessThn</span> <span class="p">(</span><span class="kt">AtmInt</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="kt">AtmInt</span> <span class="n">n2</span><span class="p">))</span> <span class="o">=</span>
  <span class="p">[(</span><span class="s">"cmpq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">n2</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="p">(</span><span class="n">show</span> <span class="n">n</span><span class="p">))]</span>
<span class="kt">In</span> <span class="n">this</span> <span class="n">pass</span><span class="p">,</span> <span class="n">instead</span> <span class="kr">of</span> <span class="n">using</span> <span class="n">stack</span> <span class="n">locations</span> <span class="n">or</span> <span class="n">registers</span> <span class="n">we</span> <span class="n">use</span> <span class="n">the</span> <span class="n">actual</span> <span class="n">variable</span> <span class="n">names</span><span class="o">.</span> <span class="kt">In</span> <span class="n">the</span> <span class="n">next</span> <span class="n">pass</span> <span class="n">we</span> <span class="n">assign</span> <span class="n">stack</span> <span class="n">locations</span>

<span class="n">toSelect</span> <span class="p">(</span><span class="kt">MonWhile</span> <span class="n">cnd</span> <span class="p">(</span><span class="kt">MonIf</span> <span class="n">cnd2</span> <span class="n">thn</span> <span class="n">els</span><span class="p">))</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="n">cif</span> <span class="o">=</span> <span class="n">toCLikewhile</span> <span class="p">(</span><span class="kt">MonIf</span> <span class="n">cnd2</span> <span class="n">thn</span> <span class="n">els</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="s">"jmp"</span><span class="p">,</span> <span class="s">"to"</span><span class="p">,</span> <span class="kt">MonBlock</span> <span class="s">"whiletest"</span><span class="p">,</span> <span class="s">"thanks"</span><span class="p">,</span> <span class="s">":)"</span><span class="p">)</span><span class="kr">in</span>
    <span class="kr">let</span> <span class="n">cselect</span> <span class="o">=</span> <span class="n">toSelect</span> <span class="n">cif</span> <span class="kr">in</span>
      <span class="kr">let</span> <span class="n">selectcnd</span> <span class="o">=</span> <span class="n">toSelect</span> <span class="n">cnd</span> <span class="kr">in</span>
      <span class="p">[(</span><span class="s">"whiletest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"whiletestlabel"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">":"</span><span class="p">)]</span> <span class="o">++</span> <span class="n">selectcnd</span> <span class="o">++</span> <span class="p">[(</span><span class="s">"jge"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"exit"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span> <span class="p">(</span><span class="s">"jmp"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"iftest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">)]</span> <span class="o">++</span> <span class="p">[(</span><span class="s">"iftest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"iftestlabel"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">)]</span> <span class="o">++</span> <span class="n">cselect</span> <span class="o">++</span> <span class="p">[(</span><span class="s">"exit"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"retq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">)]</span>

</code></pre></div></div>

<p>Note: the dummy arguments are one of the weaknesses of my implementation. In the next iteration of the project I am going to build a much cleaner design.</p>

<p>Anyways, the instruction selection pass generates three address code whose addresses are variables from the source program.</p>

<p>Since I did not implement register allocation, I have another pass which assigns stack locations:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
    <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="s">"-8(%rbp)"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"whiletest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"whiletestlabel"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">":"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"cmpq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="mi">4</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="s">"-8(%rbp)"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"jge"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"exit"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"jmp"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"iftest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"iftest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"iftestlabel"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"cmpq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="mi">5</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="s">"-8(%rbp)"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"jmp"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"block_0"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"je"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"block_1"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"block_0"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"blkdummy"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="s">"-8(%rbp)"</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="s">"%rdi"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"print"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"incq"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="s">"-8(%rbp)"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"jmp"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"whiletest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"thanks"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"block_1"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"3"</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="s">"%rdi"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"print"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"jmp"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"whiletest"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"thanks"</span><span class="p">),</span>
    <span class="p">(</span><span class="s">"exit"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"retq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">)</span>
<span class="p">]</span>

</code></pre></div></div>

<p>And the code that generates stack locations is here:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">toStackHelper</span> <span class="o">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Imm</span><span class="p">,</span> <span class="kt">Imm</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Imm</span><span class="p">,</span> <span class="kt">Imm</span><span class="p">)]</span>
<span class="n">toStackHelper</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">toStackHelper</span> <span class="p">((</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">n</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="s">"%rdi"</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
  <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="p">(</span><span class="n">show</span> <span class="n">n</span><span class="p">),</span> <span class="kt">ImmReg</span> <span class="s">"%rdi"</span><span class="p">)</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter</span> <span class="n">hashmap</span>
  
<span class="n">toStackHelper</span> <span class="p">((</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">imm1</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">tmp1</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">stacklocation</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span> <span class="o">=</span>
            <span class="kr">if</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="n">tmp1</span> <span class="n">hashmap</span>
            <span class="kr">then</span> <span class="p">(</span><span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">hashmap</span><span class="p">)</span>
            <span class="kr">else</span> <span class="kr">let</span> <span class="n">counter'</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">8</span>
                     <span class="n">stacklocation'</span> <span class="o">=</span> <span class="s">"-"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">counter'</span> <span class="o">++</span> <span class="s">"(%rbp)"</span>
                     <span class="n">hashmap'</span> <span class="o">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">tmp1</span> <span class="n">stacklocation'</span> <span class="n">hashmap</span>
                 <span class="kr">in</span> <span class="p">(</span><span class="n">stacklocation'</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span>
    <span class="kr">in</span>
        <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">imm1</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stacklocation</span><span class="p">)</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter'</span> <span class="n">hashmap'</span>

<span class="n">toStackHelper</span> <span class="p">((</span><span class="s">"addq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">imm1</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">tmp1</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="p">(</span><span class="n">stacklocation</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span> <span class="o">=</span>
        <span class="kr">if</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="n">tmp1</span> <span class="n">hashmap</span>
        <span class="kr">then</span> <span class="p">(</span><span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">hashmap</span><span class="p">)</span>
        <span class="kr">else</span> <span class="kr">let</span> <span class="n">counter'</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">8</span>
                 <span class="n">stacklocation'</span> <span class="o">=</span> <span class="s">"-"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">counter'</span> <span class="o">++</span> <span class="s">"(%rbp)"</span>
                 <span class="n">hashmap'</span> <span class="o">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">tmp1</span> <span class="n">stacklocation'</span> <span class="n">hashmap</span>
               <span class="kr">in</span> <span class="p">(</span><span class="n">stacklocation'</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span>
   <span class="kr">in</span>
    <span class="p">(</span><span class="s">"addq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="p">(</span><span class="n">show</span> <span class="n">imm1</span><span class="p">),</span> <span class="kt">ImmStack</span> <span class="n">stacklocation</span><span class="p">)</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter'</span> <span class="n">hashmap'</span>

<span class="n">toStackHelper</span> <span class="p">((</span><span class="s">"addq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">imm1</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">tmp1</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="p">(</span><span class="n">stacklocation</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">,</span> <span class="n">stacklocation2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">hashmap</span><span class="p">,</span> <span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">imm1</span><span class="p">)</span>
       
   <span class="kr">in</span>
     <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">stacklocation</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="s">"%rax"</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="s">"addq"</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="s">"%rax"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stacklocation2</span><span class="p">)</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter'</span> <span class="n">hashmap'</span>

<span class="n">toStackHelper</span> <span class="p">((</span><span class="s">"incq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dummy</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="p">(</span><span class="n">stacklocation</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">x</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">hashmap</span><span class="p">)</span>
  <span class="kr">in</span>
    <span class="p">(</span><span class="s">"incq"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stacklocation</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">)</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter'</span> <span class="n">hashmap'</span>
  
<span class="n">toStackHelper</span> <span class="p">((</span><span class="s">"subq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">n</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">tmp1</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="p">(</span><span class="n">stacklocation</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span> <span class="o">=</span>
        <span class="kr">if</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="n">tmp1</span> <span class="n">hashmap</span>
        <span class="kr">then</span> <span class="p">(</span><span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">hashmap</span><span class="p">)</span>
        <span class="kr">else</span> <span class="kr">let</span> <span class="n">counter'</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">8</span>
                 <span class="n">stacklocation'</span> <span class="o">=</span> <span class="s">"-"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">counter'</span> <span class="o">++</span> <span class="s">"(%rbp)"</span>
                 <span class="n">hashmap'</span> <span class="o">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">tmp1</span> <span class="n">stacklocation'</span> <span class="n">hashmap</span>
               <span class="kr">in</span> <span class="p">(</span><span class="n">stacklocation'</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span>
   <span class="kr">in</span>
    <span class="p">(</span><span class="s">"subq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stacklocation</span><span class="p">)</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter'</span> <span class="n">hashmap'</span>
    
<span class="n">toStackHelper</span> <span class="p">((</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"True"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">tmp1</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">stacklocation</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span> <span class="o">=</span>
            <span class="kr">if</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="n">tmp1</span> <span class="n">hashmap</span>
            <span class="kr">then</span> <span class="p">(</span><span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">hashmap</span><span class="p">)</span>
            <span class="kr">else</span> <span class="kr">let</span> <span class="n">counter'</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">8</span>
                     <span class="n">stacklocation'</span> <span class="o">=</span> <span class="s">"-"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">counter'</span> <span class="o">++</span> <span class="s">"(%rbp)"</span>
                     <span class="n">hashmap'</span> <span class="o">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">tmp1</span> <span class="n">stacklocation'</span> <span class="n">hashmap</span>
                 <span class="kr">in</span> <span class="p">(</span><span class="n">stacklocation'</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span>
    <span class="kr">in</span>
        <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"True"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stacklocation</span><span class="p">)</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter'</span> <span class="n">hashmap'</span>

<span class="n">toStackHelper</span> <span class="p">((</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"False"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">tmp1</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">stacklocation</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span> <span class="o">=</span>
            <span class="kr">if</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="n">tmp1</span> <span class="n">hashmap</span>
            <span class="kr">then</span> <span class="p">(</span><span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">hashmap</span><span class="p">)</span>
            <span class="kr">else</span> <span class="kr">let</span> <span class="n">counter'</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">8</span>
                     <span class="n">stacklocation'</span> <span class="o">=</span> <span class="s">"-"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">counter'</span> <span class="o">++</span> <span class="s">"(%rbp)"</span>
                     <span class="n">hashmap'</span> <span class="o">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">tmp1</span> <span class="n">stacklocation'</span> <span class="n">hashmap</span>
                 <span class="kr">in</span> <span class="p">(</span><span class="n">stacklocation'</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span>
    <span class="kr">in</span>
        <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"True"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stacklocation</span><span class="p">)</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter'</span> <span class="n">hashmap'</span>
        
<span class="n">toStackHelper</span> <span class="p">((</span><span class="s">"cmpq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">bool</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">tmp1</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="p">(</span><span class="n">stacklocation</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">hashmap</span><span class="p">)</span>
       
   <span class="kr">in</span>
     <span class="p">(</span><span class="s">"cmpq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">bool</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stacklocation</span><span class="p">)</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter'</span> <span class="n">hashmap'</span>

<span class="n">toStackHelper</span> <span class="p">((</span><span class="s">"cmpq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">n</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">tmp1</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="p">(</span><span class="n">stacklocation</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">hashmap</span><span class="p">)</span>
       
   <span class="kr">in</span>
     <span class="p">(</span><span class="s">"cmpq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">n</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stacklocation</span><span class="p">)</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter'</span> <span class="n">hashmap'</span>

<span class="n">toStackHelper</span> <span class="p">((</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">imm1</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="s">"%rdi"</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">stacklocation</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span> <span class="o">=</span>
            <span class="kr">if</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="n">imm1</span> <span class="n">hashmap</span>
            <span class="kr">then</span> <span class="p">(</span><span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">imm1</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">hashmap</span><span class="p">)</span>
            <span class="kr">else</span> <span class="kr">let</span> <span class="n">counter'</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">8</span>
                     <span class="n">stacklocation'</span> <span class="o">=</span> <span class="s">"-"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">counter'</span> <span class="o">++</span> <span class="s">"(%rbp)"</span>
                     <span class="n">hashmap'</span> <span class="o">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">imm1</span> <span class="n">stacklocation'</span> <span class="n">hashmap</span>
                 <span class="kr">in</span> <span class="p">(</span><span class="n">stacklocation'</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">)</span>
    <span class="kr">in</span>
        <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stacklocation</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="s">"%rdi"</span><span class="p">)</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter'</span> <span class="n">hashmap'</span>

<span class="n">toStackHelper</span> <span class="p">((</span><span class="s">"print"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
  <span class="p">(</span><span class="s">"print"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"dummy"</span><span class="p">)</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter</span> <span class="n">hashmap</span>

<span class="n">toStackHelper</span> <span class="p">((</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">v2</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
   <span class="kr">let</span> <span class="p">(</span><span class="n">stacklocation</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">,</span> <span class="n">stacklocation2</span><span class="p">)</span> <span class="o">=</span>
            <span class="kr">if</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="n">v</span> <span class="n">hashmap</span> <span class="o">&amp;&amp;</span> <span class="n">not</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="n">v2</span> <span class="n">hashmap</span><span class="p">)</span>
            <span class="kr">then</span> <span class="kr">let</span> <span class="n">counter'</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">8</span>
                     <span class="n">stacklocation2</span> <span class="o">=</span> <span class="s">"-"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">counter'</span> <span class="o">++</span> <span class="s">"(%rbp)"</span>
                     <span class="n">hashmap'</span> <span class="o">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">v2</span> <span class="n">stacklocation2</span> <span class="n">hashmap</span>
                 <span class="kr">in</span>
                   <span class="p">(</span><span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">v</span><span class="p">,</span> <span class="n">counter'</span><span class="p">,</span> <span class="n">hashmap'</span><span class="p">,</span> <span class="n">stacklocation2</span><span class="p">)</span>
            <span class="kr">else</span> <span class="p">(</span><span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">v</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">hashmap</span><span class="p">,</span> <span class="n">hashmap</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">v2</span><span class="p">)</span>
    <span class="kr">in</span>
     <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stacklocation</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="s">"%rax"</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="s">"%rax"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stacklocation2</span><span class="p">)</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter'</span> <span class="n">hashmap'</span>

<span class="n">toStackHelper</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">counter</span> <span class="n">hashmap</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">:</span> <span class="n">toStackHelper</span> <span class="n">xs</span> <span class="n">counter</span> <span class="n">hashmap</span>

</code></pre></div></div>

<p>And finally we generate the actual x86:</p>

<pre><code class="language-x86asm">    .globl main
main:
    pushq %rbp
    movq %rsp, %rbp
    subq $8, %rsp
    movq $0, -8(%rbp)
whiletest:
    cmpq $4, -8(%rbp)
    jge exit
    jmp iftest
iftest:
    cmpq $5, -8(%rbp)
    jmp block_0
    je block_1
block_0:
    movq -8(%rbp), %rdi
    callq print_int
    incq -8(%rbp)
    jmp whiletest
block_1:
    movq $3, %rdi
    callq print_int
    jmp whiletest
exit:
    addq $8, %rsp
    popq %rbp
    retq

</code></pre>

<p>which is associated with this code:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">toX86'</span> <span class="o">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Imm</span><span class="p">,</span> <span class="kt">Imm</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">toX86'</span> <span class="kt">[]</span> <span class="o">=</span> <span class="s">""</span>

<span class="n">toX86'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">toX86W</span> <span class="n">x</span> <span class="o">++</span> <span class="n">toX86'</span> <span class="n">xs</span>
  
<span class="n">toX86W</span> <span class="o">::</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Imm</span><span class="p">,</span> <span class="kt">Imm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">toX86W</span> <span class="p">(</span><span class="s">"start"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dummy</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dummy2</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">.globl main</span><span class="se">\n</span><span class="s">"</span> <span class="o">++</span> <span class="s">"main:</span><span class="se">\n</span><span class="s">"</span> <span class="o">++</span> <span class="s">"</span><span class="se">\t</span><span class="s">pushq %rbp</span><span class="se">\n</span><span class="s">"</span> <span class="o">++</span> <span class="s">"</span><span class="se">\t</span><span class="s">movq %rsp, %rbp</span><span class="se">\n</span><span class="s">"</span> <span class="o">++</span> <span class="s">"</span><span class="se">\t</span><span class="s">subq $8, %rsp</span><span class="se">\n</span><span class="s">"</span> 

<span class="n">toX86W</span> <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"True"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stack</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">movq $1, "</span> <span class="o">++</span> <span class="n">stack</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span> 

<span class="n">toX86W</span> <span class="p">(</span><span class="s">"cmpq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"True"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stack</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">cmpq $1, "</span> <span class="o">++</span> <span class="n">stack</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span> 
<span class="n">toX86W</span> <span class="p">(</span><span class="s">"cmpq"</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="n">reg2</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">cmpq "</span> <span class="o">++</span> <span class="n">reg</span> <span class="o">++</span> <span class="s">","</span> <span class="o">++</span> <span class="n">reg2</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
  
<span class="n">toX86W</span> <span class="p">(</span><span class="s">"jmp"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">block</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dummy</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">jmp "</span> <span class="o">++</span> <span class="n">block</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span> 

<span class="n">toX86W</span> <span class="p">(</span><span class="s">"je"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">block</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dummy</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">je "</span> <span class="o">++</span> <span class="n">block</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>

<span class="n">toX86W</span> <span class="p">(</span><span class="s">"jge"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">block</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dummy</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">jge "</span> <span class="o">++</span> <span class="n">block</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>

<span class="n">toX86W</span> <span class="p">(</span><span class="s">"jl"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">block</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dummy</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">jl "</span> <span class="o">++</span> <span class="n">block</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span> 
  
<span class="n">toX86W</span> <span class="p">(</span><span class="s">"exit"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="s">"retq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dmy</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"exit:</span><span class="se">\n</span><span class="s">"</span> <span class="o">++</span> <span class="s">"</span><span class="se">\t</span><span class="s">addq $8, %rsp</span><span class="se">\n</span><span class="s">"</span> <span class="o">++</span> <span class="s">"</span><span class="se">\t</span><span class="s">popq %rbp</span><span class="se">\n</span><span class="s">"</span> <span class="o">++</span>  <span class="s">"</span><span class="se">\t</span><span class="s">retq</span><span class="se">\n</span><span class="s">"</span>
  
<span class="n">toX86W</span> <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="n">reg2</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">movq "</span>  <span class="o">++</span> <span class="n">reg</span> <span class="o">++</span> <span class="s">","</span> <span class="o">++</span> <span class="n">reg2</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>

<span class="n">toX86W</span> <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">n</span><span class="p">,</span> <span class="kt">TupleMem</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">=</span>
   <span class="s">"</span><span class="se">\t</span><span class="s">movq "</span>  <span class="o">++</span> <span class="s">"$"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">","</span> <span class="o">++</span> <span class="n">tmp</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
   
<span class="n">toX86W</span> <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">TupleMem</span> <span class="n">tmp</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="n">reg</span><span class="p">)</span> <span class="o">=</span>
   <span class="s">"</span><span class="se">\t</span><span class="s">movq "</span> <span class="o">++</span> <span class="n">tmp</span> <span class="o">++</span> <span class="s">","</span> <span class="o">++</span> <span class="n">reg</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
   
<span class="n">toX86W</span> <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">n</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="n">reg</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">movq "</span>  <span class="o">++</span> <span class="n">n</span> <span class="o">++</span> <span class="s">","</span> <span class="o">++</span> <span class="n">reg</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>

   
<span class="n">toX86W</span> <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">n</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="n">reg</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">movq "</span>  <span class="o">++</span> <span class="s">"$"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">","</span> <span class="o">++</span> <span class="n">reg</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
  
<span class="n">toX86W</span> <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">n</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stk</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">movq $"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">", "</span> <span class="o">++</span> <span class="n">stk</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>

<span class="n">toX86W</span> <span class="p">(</span><span class="s">"movq"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stk</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="n">reg</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">movq "</span> <span class="o">++</span> <span class="n">stk</span> <span class="o">++</span> <span class="s">", "</span> <span class="o">++</span> <span class="n">reg</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>

<span class="n">toX86W</span> <span class="p">(</span><span class="s">"incq"</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stk</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dummy</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">incq "</span> <span class="o">++</span> <span class="n">stk</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>

<span class="n">toX86W</span> <span class="p">(</span><span class="s">"callq"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dmy</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">callq "</span> <span class="o">++</span> <span class="n">fn</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
  
<span class="n">toX86W</span> <span class="p">(</span><span class="s">"cmpq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">n</span><span class="p">,</span> <span class="kt">ImmStack</span> <span class="n">stk</span><span class="p">)</span> <span class="o">=</span>
    <span class="s">"</span><span class="se">\t</span><span class="s">cmpq $"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">", "</span> <span class="o">++</span> <span class="n">stk</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>

<span class="n">toX86W</span> <span class="p">(</span><span class="s">"print"</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dm</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dm2</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">callq "</span> <span class="o">++</span> <span class="s">"print_int</span><span class="se">\n</span><span class="s">"</span> 
  
<span class="n">toX86W</span> <span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dm</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">dm2</span><span class="p">)</span><span class="o">=</span>
  <span class="n">b1</span> <span class="o">++</span> <span class="s">":</span><span class="se">\n</span><span class="s">"</span>

<span class="n">toX86W</span> <span class="p">(</span><span class="s">"addq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">n</span><span class="p">,</span> <span class="kt">ImmReg</span> <span class="n">reg</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">addq "</span> <span class="o">++</span> <span class="s">"$"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">", "</span> <span class="o">++</span> <span class="n">reg</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>

<span class="n">toX86W</span> <span class="p">(</span><span class="s">"addq"</span><span class="p">,</span> <span class="kt">ImmInt</span> <span class="n">n</span><span class="p">,</span> <span class="kt">ImmStr</span> <span class="n">fp</span><span class="p">)</span> <span class="o">=</span>
  <span class="s">"</span><span class="se">\t</span><span class="s">addq "</span> <span class="o">++</span> <span class="s">"$"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">", "</span> <span class="o">++</span>  <span class="n">fp</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
</code></pre></div></div>

<h3 id="tuples">Tuples</h3>

<p>It was fun compiling tuples. Tuples motivate garbage collector. The garbage collector of my system (which was not written by me) is a two space collector. The collector is divided into regions: <em>ToSpace</em> and <em>FromSpace</em>. To make room, the garbage collector, moves the reachable objects from the <em>FromSpace</em> to <em>ToSpace</em>.</p>

<p>To compile tuples you need to make a 64 bit tag for the garbage collector to distinguish it.
Tuples go through the same passes as above. In the 64 bit tag, there are bits corresponding to the size of the tuple, bits that corresponds to whether an element of the tuple is a number or another tuple and bits that correspond to whether the tuple is reachable from the root set.</p>

<p>A given tuple containing expression</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x = (4;5;6);; print(x[1]);
</code></pre></div></div>

<p>it generates the following x86</p>

<pre><code class="language-x86asm">    .globl main
main:
    pushq %rbp
    movq %rsp, %rbp
    subq $0, %rsp
    movq $65536, %rdi
    movq $65536, %rsi
    callq initialize
    movq rootstack_begin(%rip), %r15
    movq $0, 0(%r15)
    addq $8, %r15
    jmp start
start:
    movq free_ptr(%rip), %rax
    addq $24, %rax
    movq fromspace_end(%rip), %r13
    cmpq %r13, %rax
    jl block_77
    jmp block_78
block_77:
    movq $0, %r13
    jmp block_80
block_78:
    movq %r15, %rdi
    movq $24, %rsi
    callq collect
    jmp block_80
block_80:
    movq free_ptr(%rip), %r11
    addq $32, free_ptr(%rip)
    movq $7, 0(%r11)
    movq %r11, %r14
    movq %r14, %r11
    movq $4, 8(%r11)
    movq $5, 16(%r11)
    movq $6, 24(%r11)
    movq 16(%r11), %rdi
    callq print_int
    jmp conclusion
conclusion:
    subq $8, %r15
    addq $0, %rsp
    popq %rbp
    retq

</code></pre>

<h3 id="lessons-from-using-haskell">Lessons from using Haskell</h3>

<p>I have written compilers in Common Lisp and after writing a compiler in  Haskell I noticed that I was able to structure my code better. In compilers you deal with a lot of abstract syntax tree transformations. Defining data types with <code class="language-plaintext highlighter-rouge">data</code> enables you to manipulate ASTs better. Haskell’s pattern matching facility makes AST transformation feasible as well. I liked how I can break down a function into small modules based on the AST pattern. All of this enables you to structure your code.</p>

<p>Haskell lets you write:</p>

<p>Correct code, if a Haskell program compiles then it just works. Why is this? It has to do with the type system. By defining data types for each intermediate language and a signature enforced by the type system, you are forced to write more complete/less sloppy code and you are also guaranteed correctness. In addition, since the type system is about proving certain aspects of your program, when developing a program in Haskell, if the given program does not compile then the type errors will guide you to, in essence, prove your program correct iteratively.</p>

<p>If type checkers are primitive proof systems then type checkers prove parts of your system correct. If type checkers prove parts of you’re program correct then type errors will guide you prove the correctness of some parts of your program correct iteratively.</p>

<p>There are a few things I would do differently next time. I think I need to think ahead of time the structure of my data; for example, the instruction selection pass (ToSelect.hs) returns an Imm data type. An Imm is either an ImmStr, ImmReg, or ImmTupMem. Some ImmStr’s contain dummy variables “dummy”.</p>]]></content><author><name>Job Hernandez Lara</name></author><category term="compilers" /><category term="internals" /><summary type="html"><![CDATA[I would like to share a bit about compiling core programming constructs; recently, I implemented a compiler in Haskell that lowered core constructs such as tuples, if expressions, loops, comparison operators (i.e., &lt;, &gt;) and assignment and simple arithmetic.]]></summary></entry><entry><title type="html">Adding floating point multiplication to LLVM libc</title><link href="http://localhost:4000/2024/06/12/implementing-fmul-for-llvm.html" rel="alternate" type="text/html" title="Adding floating point multiplication to LLVM libc" /><published>2024-06-12T00:00:00-07:00</published><updated>2024-06-12T00:00:00-07:00</updated><id>http://localhost:4000/2024/06/12/implementing-fmul-for-llvm</id><content type="html" xml:base="http://localhost:4000/2024/06/12/implementing-fmul-for-llvm.html"><![CDATA[<p>Recently, my <em>fmul</em> pr got merged into LLVM. And I would like to talk about my contribution. You can see my pr <a href="https://github.com/llvm/llvm-project/pull/91537">here</a>.</p>

<p>The problem was to multiply two double precision numbers and return a single precision number – i.e.,</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">fmul</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>Before I go over my implementation I am going to introduce some terms.</p>

<p>A floating point number is made of three bit fields: the sign field, exponent field, and mantissa field. The sign field is always one bit irrespective of the type. In contrast the exponent field and mantissa field vary with the type.</p>

<p>For example, for double precision, the mantissa field is 53 bits, and the exponent field is 11 bits. The maximum exponent of a double precision is 1023 and minimum exponent is -1022. You will see how these maximum and minimum exponents are used in a second.</p>

<p>On the other hand, for single precision, the mantissa field is 23 bits, and the exponent field is 8 bits. The maximum exponent is 127 and the minimum exponent is -126.</p>

<h3 id="the-implementation">The implementation</h3>

<p>First, we need to get the bit representation of the double precision inputs and compute the sign bit of the result.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">auto</span> <span class="n">x_bits</span> <span class="o">=</span> <span class="n">fputil</span><span class="o">::</span><span class="n">FPBits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

 <span class="k">auto</span> <span class="n">y_bits</span> <span class="o">=</span> <span class="n">fputil</span><span class="o">::</span><span class="n">FPBits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

 <span class="k">auto</span> <span class="n">output_sign</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_bits</span><span class="p">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">!=</span> <span class="n">y_bits</span><span class="p">.</span><span class="n">sign</span><span class="p">())</span> <span class="o">?</span> <span class="n">Sign</span><span class="o">::</span><span class="n">NEG</span> <span class="o">:</span> <span class="n">Sign</span><span class="o">::</span><span class="n">POS</span><span class="p">;</span>
</code></pre></div></div>

<p>Here,</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fputil</span><span class="o">::</span><span class="n">FPBits</span>
</code></pre></div></div>

<p>Is internal LLVM code that can help you manipulate bits.</p>

<p>Next, we have the following that checks for special values like <em>NaNs</em> and <em>infinities</em>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">LIBC_UNLIKELY</span><span class="p">(</span><span class="n">x_bits</span><span class="p">.</span><span class="n">is_inf_or_nan</span><span class="p">()</span> <span class="o">||</span> <span class="n">y_bits</span><span class="p">.</span><span class="n">is_inf_or_nan</span><span class="p">()</span> <span class="o">||</span>
                	<span class="n">x_bits</span><span class="p">.</span><span class="n">is_zero</span><span class="p">()</span> <span class="o">||</span> <span class="n">y_bits</span><span class="p">.</span><span class="n">is_zero</span><span class="p">()))</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x_bits</span><span class="p">.</span><span class="n">is_nan</span><span class="p">())</span>
  	<span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">y_bits</span><span class="p">.</span><span class="n">is_nan</span><span class="p">())</span>
  	<span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x_bits</span><span class="p">.</span><span class="n">is_inf</span><span class="p">())</span>
  	<span class="k">return</span> <span class="n">y_bits</span><span class="p">.</span><span class="n">is_zero</span><span class="p">()</span>
             	<span class="o">?</span> <span class="n">fputil</span><span class="o">::</span><span class="n">FPBits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">quiet_nan</span><span class="p">().</span><span class="n">get_val</span><span class="p">()</span>
             	<span class="o">:</span> <span class="n">fputil</span><span class="o">::</span><span class="n">FPBits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">inf</span><span class="p">(</span><span class="n">output_sign</span><span class="p">).</span><span class="n">get_val</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">y_bits</span><span class="p">.</span><span class="n">is_inf</span><span class="p">())</span>
  	<span class="k">return</span> <span class="n">x_bits</span><span class="p">.</span><span class="n">is_zero</span><span class="p">()</span>
             	<span class="o">?</span> <span class="n">fputil</span><span class="o">::</span><span class="n">FPBits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">quiet_nan</span><span class="p">().</span><span class="n">get_val</span><span class="p">()</span>
             	<span class="o">:</span> <span class="n">fputil</span><span class="o">::</span><span class="n">FPBits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">inf</span><span class="p">(</span><span class="n">output_sign</span><span class="p">).</span><span class="n">get_val</span><span class="p">();</span>
	<span class="c1">// Now either x or y is zero, and the other one is finite.</span>
	<span class="k">return</span> <span class="n">fputil</span><span class="o">::</span><span class="n">FPBits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">zero</span><span class="p">(</span><span class="n">output_sign</span><span class="p">).</span><span class="n">get_val</span><span class="p">();</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>After that, you need to extract the mantissa of the inputs and extract the exponents and then compute the leading zeros of the mantissas. Why do we compute the leading zeros. We do this to normalize the inputs. After the following lines of code is executed the highest bits of <em>mx</em> and <em>my</em> are both 1. As a result, when we compute the product of the mantissas the leading one of the full product will be either the highest bit or the second highest bit. Then in the next step we know we need to shift by some amount. If we had not shifted the zeros of <em>mx</em> and <em>my</em> the leading one could be anywhere.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  <span class="kt">uint64_t</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">;</span>

  <span class="c1">// Get mantissa and append the hidden bit if needed.</span>
  <span class="n">mx</span> <span class="o">=</span> <span class="n">x_bits</span><span class="p">.</span><span class="n">get_explicit_mantissa</span><span class="p">();</span>
  <span class="n">my</span> <span class="o">=</span> <span class="n">y_bits</span><span class="p">.</span><span class="n">get_explicit_mantissa</span><span class="p">();</span>

  <span class="c1">// Get the corresponding biased exponent.</span>
  <span class="kt">int</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">x_bits</span><span class="p">.</span><span class="n">get_explicit_exponent</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">ey</span> <span class="o">=</span> <span class="n">y_bits</span><span class="p">.</span><span class="n">get_explicit_exponent</span><span class="p">();</span>

  <span class="c1">// Count the number of leading zeros of the explicit mantissas.</span>
  <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">::</span><span class="n">countl_zero</span><span class="p">(</span><span class="n">mx</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">::</span><span class="n">countl_zero</span><span class="p">(</span><span class="n">my</span><span class="p">);</span>
  <span class="c1">// Shift the leading 1 bit to the most significant bit.</span>
  <span class="n">mx</span> <span class="o">&lt;&lt;=</span> <span class="n">nx</span><span class="p">;</span>
  <span class="n">my</span> <span class="o">&lt;&lt;=</span> <span class="n">ny</span><span class="p">;</span>
</code></pre></div></div>

<p>If <em>x</em> is normal then <em>mx’s</em> leading bit is at the 53rd bit. This associated with the fact that the mantissa field of a double precision is 53 bits long. But since we shifted the leading bit to the 64th bit for normalization we need to shift it left by 11 bits.</p>

<p>If x is normal nothing changes because the leading bit is not lower than the 53rd bit. So, if its normal, <em>ex</em> represents the real value of the leading 1 bit. But if x is denormal then the leading 1 bit is lower than the 53rd bit so it does not represent  the real value of the leading bit of <em>mx</em> anymore.</p>

<p>So, we adjust the exponent accordingly:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Adjust exponent accordingly: If x or y are normal, we will only need to</span>
  <span class="c1">// shift by (exponent length + sign bit = 11 bits. If x or y are denormal, we</span>
  <span class="c1">// will need to shift more than 11 bits.</span>
  <span class="n">ex</span> <span class="o">-=</span> <span class="p">(</span><span class="n">nx</span> <span class="o">-</span> <span class="mi">11</span><span class="p">);</span>
  <span class="n">ey</span> <span class="o">-=</span> <span class="p">(</span><span class="n">ny</span> <span class="o">-</span> <span class="mi">11</span><span class="p">);</span>
</code></pre></div></div>

<p>Now, we need to prepare the actual computation of the product’s mantissa.</p>

<p>For that, since the product of two 64 bit numbers is a 128 bit number we need to store the highest 64 bits and the lowest 64 bits in two variables. And we need a way to detect if the product is normal is denormal:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UInt128</span> <span class="n">product</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">UInt128</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span> <span class="o">*</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">UInt128</span><span class="o">&gt;</span><span class="p">(</span><span class="n">my</span><span class="p">);</span>
  <span class="kt">int32_t</span> <span class="n">dm1</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">highs</span><span class="p">,</span> <span class="n">lows</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">g</span><span class="p">,</span> <span class="n">hight</span><span class="p">,</span> <span class="n">lowt</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">m</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">b</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>

  <span class="n">highs</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">product</span> <span class="o">&gt;&gt;</span> <span class="mi">64</span><span class="p">);</span> <span class="c1">// top highest 64 bit of the product</span>
  <span class="n">c</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">highs</span> <span class="o">&gt;=</span> <span class="mh">0x8000000000000000</span><span class="p">);</span> <span class="c1">// leading 1 bit is at bit 64 or not</span>
  <span class="n">lows</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">product</span><span class="p">);</span> <span class="c1">// lowest 64 bits of the product</span>

  <span class="n">lowt</span> <span class="o">=</span> <span class="p">(</span><span class="n">lows</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// sticky bit which will be used for rounding</span>

  <span class="n">dm1</span> <span class="o">=</span> <span class="n">ex</span> <span class="o">+</span> <span class="n">ey</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">fputil</span><span class="o">::</span><span class="n">FPBits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">EXP_BIAS</span><span class="p">;</span> <span class="c1">// biased exponent of the product</span>

</code></pre></div></div>

<p>In the textbook “Handbook of Floating Point Arithmetic” the reference implementation was for single precision:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">fmul</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>So the formula for <em>dm1</em> was different. It needed to be changed because since the result is a 32 bit number and hence the exponent field is 8 bits, <em>dm1</em> needs to be a number that is within the range of what an 8 bit number can represent.</p>

<p>And now we need to actually round the and get the products mantissa.</p>

<p>When a number underflows or overflows we need to wrap around by returning the highest value that a given n-bit number can represent. Well, similarly, floating point multiplication overflows when \(dm1 \gt 255\) because <em>dm1</em> is 8 bits and an 8 bit number has a range of up to 255.</p>

<p>If \(dm1 \lt 0\) then the value is denormal.</p>

<p>If <em>dm1</em> is 0 the mantissa needs to be right shifted by one. If it is one it needs to be right shifted by two.</p>

<p>So, if for the normal case you have:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">highs</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">39</span> <span class="o">+</span> <span class="n">c</span><span class="p">));</span>
</code></pre></div></div>

<p>Then for the denormal case you have:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">m_shift</span> <span class="o">=</span> <span class="mi">40</span> <span class="o">+</span> <span class="n">c</span> <span class="o">-</span> <span class="n">dm1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">g_shift</span> <span class="o">=</span> <span class="n">m_shift</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">h_shift</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">-</span> <span class="n">g_shift</span><span class="p">;</span>
<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_shift</span> <span class="o">&gt;=</span> <span class="mi">64</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">highs</span> <span class="o">&gt;&gt;</span> <span class="n">m_shift</span><span class="p">);</span>
</code></pre></div></div>

<p>Compared to the normal case, the extra shift for the denormal case is \(1 - dm1\) – i.e., \(m_shift =  39 + c + 1 - dm1 = 40 + c - dm1\).</p>

<p>To get the round bit, which will be used to round to all rounding modes, you shift by what you shifted <em>highs</em> minus one.</p>

<p>We manipulate <em>highs</em> only because when we normalized the inputs the leading 1 bit will be in the top most bits so you only need to shift <em>highs</em> to get the products mantissa <em>m</em>.</p>

<p>The <em>h_shift</em> has to do with clearing the mantissa and round bit so that only sticky bits are left.</p>

<p>In contrast for the normal case, you have this:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">m</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">highs</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">39</span> <span class="o">+</span> <span class="n">c</span><span class="p">));</span>
 <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">highs</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">38</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
 <span class="n">hight</span> <span class="o">=</span> <span class="p">(</span><span class="n">highs</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">26</span> <span class="o">-</span> <span class="n">c</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>So, <em>highs</em> is 64 bits. In the normal case we know that the leading 1 bit is either at the 63rd or 64th bit. We want to shift that down to bit 24 to get the product’s mantissa because the mantissa bit field of a single precision number is 24 bits.</p>

<p>If \(c = 0\) if the leading 1 is at bit 63. If \(c = 1\) then the leading bit is at bit 64.</p>

<p>Here is the code for the above:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">round_mode</span> <span class="o">=</span> <span class="n">fputil</span><span class="o">::</span><span class="n">quick_get_round</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dm1</span> <span class="o">&gt;=</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">round_mode</span> <span class="o">==</span> <span class="n">FE_TOWARDZERO</span><span class="p">)</span> <span class="o">||</span>
    	<span class="p">(</span><span class="n">round_mode</span> <span class="o">==</span> <span class="n">FE_UPWARD</span> <span class="o">&amp;&amp;</span> <span class="n">output_sign</span><span class="p">.</span><span class="n">is_neg</span><span class="p">())</span> <span class="o">||</span>
    	<span class="p">(</span><span class="n">round_mode</span> <span class="o">==</span> <span class="n">FE_DOWNWARD</span> <span class="o">&amp;&amp;</span> <span class="n">output_sign</span><span class="p">.</span><span class="n">is_pos</span><span class="p">()))</span> <span class="p">{</span>
  	<span class="k">return</span> <span class="n">fputil</span><span class="o">::</span><span class="n">FPBits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">max_normal</span><span class="p">(</span><span class="n">output_sign</span><span class="p">).</span><span class="n">get_val</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">fputil</span><span class="o">::</span><span class="n">FPBits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">inf</span><span class="p">().</span><span class="n">get_val</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">dm1</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

	<span class="kt">int</span> <span class="n">m_shift</span> <span class="o">=</span> <span class="mi">40</span> <span class="o">+</span> <span class="n">c</span> <span class="o">-</span> <span class="n">dm1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">g_shift</span> <span class="o">=</span> <span class="n">m_shift</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">h_shift</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">-</span> <span class="n">g_shift</span><span class="p">;</span>
	<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_shift</span> <span class="o">&gt;=</span> <span class="mi">64</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">highs</span> <span class="o">&gt;&gt;</span> <span class="n">m_shift</span><span class="p">);</span>

	<span class="n">g</span> <span class="o">=</span> <span class="n">g_shift</span> <span class="o">&gt;=</span> <span class="mi">64</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="n">highs</span> <span class="o">&gt;&gt;</span> <span class="n">g_shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hight</span> <span class="o">=</span> <span class="n">h_shift</span> <span class="o">&gt;=</span> <span class="mi">64</span> <span class="o">?</span> <span class="n">highs</span> <span class="o">:</span> <span class="p">(</span><span class="n">highs</span> <span class="o">&lt;&lt;</span> <span class="n">h_shift</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dm1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="n">m</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">highs</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">39</span> <span class="o">+</span> <span class="n">c</span><span class="p">));</span>
	<span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">highs</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">38</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hight</span> <span class="o">=</span> <span class="p">(</span><span class="n">highs</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">26</span> <span class="o">-</span> <span class="n">c</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">round_mode</span> <span class="o">==</span> <span class="n">FE_TONEAREST</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">g</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">hight</span> <span class="o">&amp;&amp;</span> <span class="n">lowt</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">m</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">((</span><span class="n">output_sign</span><span class="p">.</span><span class="n">is_neg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">round_mode</span> <span class="o">==</span> <span class="n">FE_DOWNWARD</span><span class="p">)</span> <span class="o">||</span>
         	<span class="p">(</span><span class="n">output_sign</span><span class="p">.</span><span class="n">is_pos</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">round_mode</span> <span class="o">==</span> <span class="n">FE_UPWARD</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hight</span> <span class="o">&amp;&amp;</span> <span class="n">lowt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Finally, we compute the exponent and cast the result to float:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="n">exp16</span> <span class="o">=</span> <span class="p">(</span><span class="n">dm1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">);</span>

<span class="kt">uint32_t</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&amp;</span> <span class="n">fputil</span><span class="o">::</span><span class="n">FPBits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">FRACTION_MASK</span><span class="p">;</span>

<span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp16</span> <span class="o">+</span> <span class="n">m2</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">result_bits</span> <span class="o">=</span> <span class="n">fputil</span><span class="o">::</span><span class="n">FPBits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="n">result_bits</span><span class="p">.</span><span class="n">set_sign</span><span class="p">(</span><span class="n">output_sign</span><span class="p">);</span>
<span class="k">return</span> <span class="n">result_bits</span><span class="p">.</span><span class="n">get_val</span><span class="p">();</span>
</code></pre></div></div>

<p>And there you have it: the implementation of:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">fmul</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>I enjoyed doing this.</p>

<h3 id="acknowledgements">Acknowledgements</h3>

<p>I want to thank Tue, the libc maintainer, for explaining a lot of this to me.</p>

<h3 id="references">References</h3>

<p>Handbook of Floating Point Arithmetic</p>]]></content><author><name>Job Hernandez Lara</name></author><category term="computer-science" /><category term="floating-point-arithmetic" /><category term="llvm" /><summary type="html"><![CDATA[Recently, my fmul pr got merged into LLVM. And I would like to talk about my contribution. You can see my pr here.]]></summary></entry><entry><title type="html">Compiler problems and their implementation</title><link href="http://localhost:4000/2024/05/02/compilers-are-interesting.html" rel="alternate" type="text/html" title="Compiler problems and their implementation" /><published>2024-05-02T00:00:00-07:00</published><updated>2024-05-02T00:00:00-07:00</updated><id>http://localhost:4000/2024/05/02/compilers-are-interesting</id><content type="html" xml:base="http://localhost:4000/2024/05/02/compilers-are-interesting.html"><![CDATA[<p>So, far in my compiler journey I have faced three interesting problems. The problems were translating a subset of language to <em>A-Normal form</em>, compiling tuples to x86, and floating point math.</p>

<h3 id="compiling-without-continuations">Compiling without continuations</h3>

<p>A-Normal form is an intermediate language for functional programming languages but it can be used to compile languages such as Python.</p>

<p>It was introduced in a paper called “The Essence of Compiling with Continuations”<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, in which the authors argued that ANF is equivalent to continuation passing style but much simpler.</p>

<p>ANF consists of atomic and complex expressions. An atomic expression is an expression that is readily computable in x86 assembly.</p>

<p>Recently, I built a compiler in Haskell for a subset of a language.</p>

<p>Here is the grammar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exp : var  { Var $1 }
| let var '=' Exp ';' { Let $2 $4 }
| Exp '+' Exp ';' { Plus $1 $3 }
| Exp '-' Exp ';' { Minus $1 $3 }
| Exp '&lt;' Exp ';'   { LessThn $1 $3 }
| Exp '&gt;' Exp ';' { GreaterThn $1 $3 }
| if Exp then Exp else Exp ';' { IfExp $2 $4 $6 }
| true { Bool $1 }
| false { Bool $1 }
| print '(' Exp ')' ';' { PrintExp $3 }
| Exp ';' Exp  { Exps $1 $3 }
| while Exp ':' Exp  { While $2 $4 }
| defun Exp '(' Exp ')' '{' Exp '}'   { DefunExp $2 $4 $7 }
| '(' Exp ')'   { TupleExp $2 }
| Exp '[' int ']'   { TupleIndex $1 $3 }
| int  { Int $1 }
| '-' int { Negative $2 }
</code></pre></div></div>

<p>Once A-Normalization is applied you end up something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>atomic  :: number | boolean | var | &lt; | &gt; | + | -
complex :: (atomic, atomic,..., atomic) | (if &lt;atomic&gt; &lt;complex&gt; &lt;complex&gt;) | (while &lt;atomic&gt; &lt;complex&gt;) | (tuple &lt;atomic&gt;)
exp     :: (let var &lt;complex&gt;) | atomic | complex
</code></pre></div></div>

<p>The interesting conversion was the \(if expression\). It required some thought. I initially wrote it in Racket and then rewrote it in Haskell. Here is both of the implementations:</p>

<p>Racket<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(define (syntax-&gt;anf ast)

  (define counter (make-parameter 0))
 
  (define (generate-temp-name name)
	(let* [(current-counter (counter))
       	(name* (string-append name (number-&gt;string current-counter)))]
  	(counter (+ current-counter 1))
  	name*))
 
  (define (to-anf ast)
	(match ast
  	    ;; …
           
     	[(py-if-exp cnd thn els)
      	(let* [(temp-name (generate-temp-name "temp-"))
             	(temp-name2 (generate-temp-name "temp-"))]
        	(list (atomic-assignment (atomic (py-id temp-name)) (to-anf cnd))
              	(atomic-assignment (atomic (py-id temp-name2))
                                 	(to-anf (py-if-exp (py-id temp-name)
                                                    	thn
                                                    	els)))
              	(to-anf (py-if-exp (py-id temp-name2) then-exp else-exp))))])]

</code></pre></div></div>

<p>And here is my Haskell<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> implementation:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">toMon</span> <span class="p">(</span><span class="kt">IfExp</span> <span class="p">(</span><span class="kt">Bool</span> <span class="n">b</span><span class="p">)</span> <span class="n">thn</span> <span class="n">els</span><span class="p">)</span> <span class="n">counter</span> <span class="o">=</span>
  <span class="kt">MonIf</span> <span class="p">(</span><span class="n">toMon</span> <span class="p">(</span><span class="kt">Bool</span> <span class="n">b</span><span class="p">)</span> <span class="n">counter</span><span class="p">)</span> <span class="p">(</span><span class="n">toMon</span> <span class="n">thn</span> <span class="n">counter</span><span class="p">)</span> <span class="p">(</span><span class="n">toMon</span> <span class="n">els</span> <span class="n">counter</span><span class="p">)</span>
<span class="n">toMon</span> <span class="p">(</span><span class="kt">IfExp</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v</span><span class="p">)</span> <span class="n">thn</span> <span class="n">els</span><span class="p">)</span> <span class="n">counter</span> <span class="o">=</span>
  <span class="kt">MonIf</span> <span class="p">(</span><span class="n">toMon</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v</span><span class="p">)</span> <span class="n">counter</span><span class="p">)</span> <span class="p">(</span><span class="n">toMon</span> <span class="n">thn</span> <span class="n">counter</span><span class="p">)</span> <span class="p">(</span><span class="n">toMon</span> <span class="n">els</span> <span class="n">counter</span><span class="p">)</span>
<span class="n">toMon</span> <span class="p">(</span><span class="kt">IfExp</span> <span class="p">(</span><span class="kt">IfExp</span> <span class="n">cnd</span> <span class="n">thn</span> <span class="n">els</span><span class="p">)</span> <span class="n">thn2</span> <span class="n">els2</span><span class="p">)</span> <span class="n">counter</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="n">tmpname</span> <span class="o">=</span> <span class="s">"temp_"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">counter</span> <span class="kr">in</span>
	<span class="kr">let</span> <span class="n">counter2</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">in</span>
  	<span class="kr">let</span> <span class="n">tmpname2</span> <span class="o">=</span> <span class="s">"temp_"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">counter2</span> <span class="kr">in</span>
    	<span class="kr">let</span> <span class="n">counter3</span> <span class="o">=</span> <span class="n">counter2</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">in</span>
      	<span class="kr">let</span> <span class="n">counter4</span> <span class="o">=</span> <span class="n">counter3</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">in</span>
        	<span class="kt">MonLstSeq</span> <span class="p">(</span><span class="kt">MonLet</span> <span class="n">tmpname</span> <span class="p">(</span><span class="n">toMon</span> <span class="n">cnd</span> <span class="n">counter3</span><span class="p">))</span> <span class="p">(</span><span class="kt">MonLet</span> <span class="n">tmpname2</span> <span class="p">(</span><span class="n">toMon</span> <span class="p">(</span><span class="kt">IfExp</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">tmpname</span><span class="p">)</span> <span class="n">thn</span> <span class="n">els</span><span class="p">)</span> <span class="n">counter4</span><span class="p">))</span> <span class="p">(</span><span class="n">toMon</span> <span class="p">(</span><span class="kt">IfExp</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">tmpname2</span><span class="p">)</span> <span class="n">thn2</span> <span class="n">els2</span><span class="p">)</span> <span class="n">counter4</span><span class="p">)</span>
   	 
<span class="n">toMon</span> <span class="p">(</span><span class="kt">IfExp</span> <span class="n">cnd</span> <span class="n">thn</span> <span class="n">els</span><span class="p">)</span> <span class="n">counter</span> <span class="o">=</span>
  <span class="kt">MonIf</span> <span class="p">(</span><span class="n">toMon</span> <span class="n">cnd</span> <span class="n">counter</span><span class="p">)</span> <span class="p">(</span><span class="n">toMon</span> <span class="n">thn</span> <span class="n">counter</span><span class="p">)</span> <span class="p">(</span><span class="n">toMon</span> <span class="n">els</span> <span class="n">counter</span><span class="p">)</span>
</code></pre></div></div>

<p>This problem requires thinking recursively which I enjoyed. The main differences between these two solutions is that in the Racket version I use mutation to create the temp variables. On the other hand, the Haskell version required me to think recursively as well but I needed to pass a counter and increment this counter to create the temp variables.</p>

<h3 id="interfacing-with-the-garbage-collector">Interfacing with the garbage collector</h3>

<p>Tuples motivate the need for garbage collection. The garbage collector needs a way to identify tuples (pointers) from other data. As a result, a 64 bit tag gets placed in the front of tuple data.</p>

<p>In the garbage collector, there are two regions: a fromSpace and toSpace region. When you allocate a tuple, a graph is constructed internally. To make space for new allocations all the tuples reachable from the root set of the graph gets copied into the toSpace region. After this the fromSpace region gets turned into the toSpace region and the toSpace becomes the fromSpace region.</p>

<h4 id="example">Example</h4>

<p>Suppose you have a tuple: (1,1,3).</p>

<p>The 64 bit tag for this tuple would be 000 000011 1.In assembly I will be using instructions that manipulate 64 bits.</p>

<p>The first three 0 bits are 0s because when processing a tuple you assign a 0 bit to an integer and  a 1 bit to a tuple.</p>

<p>000011 on the other hand is the length of the tuple. In this case 3.</p>

<p>The last bit represents whether it’s reachable from the root set.</p>

<p>example using this code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; makeTag (1;1;3)
7
</code></pre></div></div>
<p>The tag 7 will be placed in front of the tuple.</p>

<p>In my Haskell compiler, the example</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x = (4;5;6);; print(x[1]);
</code></pre></div></div>

<p>Compiles to the following x86<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.globl main
main:
    pushq %rbp
    movq %rsp, %rbp
    subq $0, %rsp
    movq $65536, %rdi
    movq $65536, %rsi
    callq initialize
    movq rootstack_begin(%rip), %r15
    movq $0, 0(%r15)
    addq $8, %r15
    jmp start
start:
    movq free_ptr(%rip),%rax
    addq $24, %rax
    movq fromspace_end(%rip),%r13
    cmpq %r13,%rax
    jl block_77
    jmp block_78
block_77:
    movq $0,%r13
    jmp block_80
block_78:
    movq %r15,%rdi
    movq $24,%rsi
    callq collect
    jmp block_80
block_80:
    movq free_ptr(%rip),%r11
    addq $32, free_ptr(%rip)
    movq $7,0(%r11)
    movq %r11,%r14
    movq %r14,%r11
    movq $4,8(%r11)
    movq $5,16(%r11)
    movq $6,24(%r11)
    movq 16(%r11),%rdi
    callq print_int
    jmp conclusion
conclusion:
    subq $8, %r15
    addq $0, %rsp
    popq %rbp
    retq
</code></pre></div></div>

<h3 id="floating-point-math">Floating point math</h3>

<p>Before my contribution to LLVM, I took floating point numbers as granted but it turns out that floating point mathematics is an entire world.</p>

<p>Floating point math is interesting because real numbers can be infinite but the machine is finite; as a result, one needs to represent an infinite number in a finite machine.</p>

<p>The issue I did for LLVM is not floating point arithmetic but it was indeed a floating point issue.</p>

<p>I implemented fmaximum and fminimum and their variants. In this type of problem I had to return NaN values in some cases.</p>

<p>But working on this issue required me to change around 140 files! So, it was the most complex thing, engineering wise, that I had done. My git skills improved a lot and my emacs’ skills did to.</p>

<p>But anyways, here is the code that I wrote<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">cpp</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">cpp</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="n">LIBC_INLINE</span> <span class="n">T</span> <span class="nf">fmaximum</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">FPBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">bitx</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">bity</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">is_nan</span><span class="p">())</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bity</span><span class="p">.</span><span class="n">is_nan</span><span class="p">())</span>
	<span class="k">return</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">!=</span> <span class="n">bity</span><span class="p">.</span><span class="n">sign</span><span class="p">())</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">is_neg</span><span class="p">()</span> <span class="o">?</span> <span class="n">y</span> <span class="o">:</span> <span class="n">x</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">cpp</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">cpp</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="n">LIBC_INLINE</span> <span class="n">T</span> <span class="nf">fminimum</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">FPBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">bitx</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">bity</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">is_nan</span><span class="p">())</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bity</span><span class="p">.</span><span class="n">is_nan</span><span class="p">())</span>
	<span class="k">return</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">!=</span> <span class="n">bity</span><span class="p">.</span><span class="n">sign</span><span class="p">())</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">is_neg</span><span class="p">())</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">cpp</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">cpp</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="n">LIBC_INLINE</span> <span class="n">T</span> <span class="nf">fmaximum_num</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">FPBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">bitx</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">bity</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">is_signaling_nan</span><span class="p">()</span> <span class="o">||</span> <span class="n">bity</span><span class="p">.</span><span class="n">is_signaling_nan</span><span class="p">())</span> <span class="p">{</span>
	<span class="n">fputil</span><span class="o">::</span><span class="n">raise_except_if_required</span><span class="p">(</span><span class="n">FE_INVALID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">is_nan</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">bity</span><span class="p">.</span><span class="n">is_nan</span><span class="p">())</span>
  	<span class="k">return</span> <span class="n">FPBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">quiet_nan</span><span class="p">().</span><span class="n">get_val</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">is_nan</span><span class="p">())</span>
	<span class="k">return</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bity</span><span class="p">.</span><span class="n">is_nan</span><span class="p">())</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">!=</span> <span class="n">bity</span><span class="p">.</span><span class="n">sign</span><span class="p">())</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">is_neg</span><span class="p">()</span> <span class="o">?</span> <span class="n">y</span> <span class="o">:</span> <span class="n">x</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">cpp</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">cpp</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="n">LIBC_INLINE</span> <span class="n">T</span> <span class="nf">fminimum_num</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">FPBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">bitx</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">bity</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">is_signaling_nan</span><span class="p">()</span> <span class="o">||</span> <span class="n">bity</span><span class="p">.</span><span class="n">is_signaling_nan</span><span class="p">())</span> <span class="p">{</span>
	<span class="n">fputil</span><span class="o">::</span><span class="n">raise_except_if_required</span><span class="p">(</span><span class="n">FE_INVALID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">is_nan</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">bity</span><span class="p">.</span><span class="n">is_nan</span><span class="p">())</span>
  	<span class="k">return</span> <span class="n">FPBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">quiet_nan</span><span class="p">().</span><span class="n">get_val</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">is_nan</span><span class="p">())</span>
	<span class="k">return</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bity</span><span class="p">.</span><span class="n">is_nan</span><span class="p">())</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">!=</span> <span class="n">bity</span><span class="p">.</span><span class="n">sign</span><span class="p">())</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bitx</span><span class="p">.</span><span class="n">is_neg</span><span class="p">()</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">y</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">cpp</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">cpp</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="n">LIBC_INLINE</span> <span class="n">T</span> <span class="nf">fmaximum_mag</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">FPBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">bitx</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">bity</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">fmaximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">cpp</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">cpp</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="n">LIBC_INLINE</span> <span class="n">T</span> <span class="nf">fminimum_mag</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">FPBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">bitx</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">bity</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">fminimum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">cpp</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">cpp</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="n">LIBC_INLINE</span> <span class="n">T</span> <span class="nf">fmaximum_mag_num</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">FPBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">bitx</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">bity</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">fmaximum_num</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">cpp</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">cpp</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="n">LIBC_INLINE</span> <span class="n">T</span> <span class="nf">fminimum_mag_num</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">FPBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">bitx</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">bity</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">fminimum_num</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="footnotes">Footnotes</h3>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://dl.acm.org/doi/pdf/10.1145/155090.155113">The Essence of Compiling with Continuations</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><a href="https://github.com/Jobhdez/To-A-Normal-Form/blob/main/src/toANF/to-anf.rkt#L138">Racket version</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p><a href="https://github.com/Jobhdez/pyhs/blob/main/src/ToMon.hs#L99">Haskell version</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p><a href="https://github.com/Jobhdez/pyhs/blob/main/src/ToSelect.hs#L160">Interfacing with the garbage collector</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p><a href="https://github.com/llvm/llvm-project/pull/86016">LLVM contribution</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Job Hernandez</name></author><category term="compilers" /><summary type="html"><![CDATA[So, far in my compiler journey I have faced three interesting problems. The problems were translating a subset of language to A-Normal form, compiling tuples to x86, and floating point math.]]></summary></entry><entry><title type="html">A minimal implementation of a deep learning compiler</title><link href="http://localhost:4000/2024/02/29/how-deep-learning-compilers-work.html" rel="alternate" type="text/html" title="A minimal implementation of a deep learning compiler" /><published>2024-02-29T00:00:00-08:00</published><updated>2024-02-29T00:00:00-08:00</updated><id>http://localhost:4000/2024/02/29/how-deep-learning-compilers-work</id><content type="html" xml:base="http://localhost:4000/2024/02/29/how-deep-learning-compilers-work.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#computational-graphs" id="markdown-toc-computational-graphs">Computational Graphs</a></li>
  <li><a href="#a-simplified-look-into-how-deep-learning-compilers-work" id="markdown-toc-a-simplified-look-into-how-deep-learning-compilers-work">A simplified look into how deep learning compilers work</a>    <ul>
      <li><a href="#example" id="markdown-toc-example">Example</a></li>
      <li><a href="#a-minimal-implementation-of-a-deep-learning-compiler" id="markdown-toc-a-minimal-implementation-of-a-deep-learning-compiler">A minimal implementation of a deep learning compiler</a></li>
    </ul>
  </li>
  <li><a href="#how-to-improve-it" id="markdown-toc-how-to-improve-it">How to improve it</a></li>
  <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
  <li><a href="#some-relevant-further-reading" id="markdown-toc-some-relevant-further-reading">Some relevant further reading</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<h3 id="introduction">Introduction</h3>

<p>Deep learning compilers are the key to deploy neural nets on different devices and architectures. And with the end of Moore’s Law, they will be increasingly important. It is my understanding that deep learning compilers are important because libraries and frameworks do not scale. It has been said by industry leaders that libraries and frameworks do not scale because the deep learning operators in these libraries are fined tuned to each computer architecture; as a result, when there is a new architecture all the deep learning operators need to be re-implemented for this architecture.</p>

<p>In other words, deep learning compilers are important because they allow engineers to cope with the diversity of hardware.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> Libraries are slow in adapting with new hardware architectures so it is hard for these libraries to utilize all the power of these architectures; moreover, deep learning compilers enable graph level optimizations and operator level optimizations.</p>

<p>In her article<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>, Chip Huyen talks about how edge computing is becoming more important. So, if you want your models to run on people’s cell phones and computers then you will need to target different architectures.</p>

<h3 id="computational-graphs">Computational Graphs</h3>

<p>A neural network is a computational graph whose nodes are deep learning operators such as convolution and tensors and the edges are dependencies among them. Technically speaking, a computational graph is a directed acyclic graph; for example, the expression:</p>

\[a + a \times (b - c) + (b - c) \times d\]

<p>is represented as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	   +
        /     \
       +        *
     /  \      / \
    /     *   /   d
    \   /  \ /
      a    -
          / \
         b   c
</code></pre></div></div>

<p>Notice that common sub expressions are only used once. DAGs, as these types of graphs, are called, work the same way in regular compilers and deep learning compilers. Sub expressions are eliminated because it enables better performance because given two common sub expressions, only one is computed. This is essentially the difference between and AST and a DAG.</p>

<p>If you take a look at the TVM<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> documentation, then it mentions that a lot of the optimizations are DAG based.</p>

<h3 id="a-simplified-look-into-how-deep-learning-compilers-work">A simplified look into how deep learning compilers work</h3>

<p>Deep learning compilers take a DAG consisting of deep learning operators such as convolution and relu and lowers it to low level code such as LLVM IR. Since in a deep learning compiler you do not need to optimize kernels manually, one can target different architectures which is why deep learning compilers scale better.</p>

<p>The following is based on this  deep learning survey.<sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> You should read it to get a better idea.</p>

<p>The frontend of a deep learning compiler consists of a high level intermediate representation (IR). This IR is a directed acyclic graph (DAG). The nodes in this graph represent the deep learning operators such as convolution and tensors. On the other hand, the edges represent dependencies. Several optimizations that are independent of the hardware are applied to this high level IR. In other words, this graph is indeed the computational graph we need to get from a given neural net model. Once we have this graph, we have access to the deep learning operators such as convolution and the tensors such as weights, and biases.</p>

<p>In addition there’s also a low level IR, which is part of the backend, to which target dependent optimizations are applied. One type of low level IR is based on Halide. When a Halide based IR is used, the computation is seperated from the schedule. Given a computation, one tries different schedules to get the best performance. A schedule is a type of optimization that can be applied such as tiling or vectorization. The idea is that by applying a series of schedules one can get better performance. This is the approach taken by TVM. In addition, the backend is also responsible for generating the actual code for the different hardware architectures.</p>

<h4 id="example">Example</h4>

<p>TVM<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup> is a state of the art deep learning compiler. TVM compiles deep learning models defined in frameworks, e.g., Pytorch, to different architectures. This compiler works by representing the computational graph in an IR called Relay; for example, consider the example from the TVM documenation<sup id="fnref:3:1" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = relay.var("x"
v1 = relay.log(x)
v2 = relay.add(v1 v1)
f = relay.Function([x], v2)
</code></pre></div></div>

<p>This example corresponds to the following computation graph</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
            var
	     |
	    log
	   /  \
           \  /
   result&lt;-add
</code></pre></div></div>

<p>In the TVM paper<sup id="fnref:4:1" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>, it talks about the type of optimizations that are applied to this Relay IR. According to the TVM paper, some of these optimizations consist of <em>operation fusion</em> whereby multiple operators are fused into a single kernel. Operation fusion improves execution time because intermediate computations do not get saved in memory. In addition to operation fusion, <em>constant fold</em> is applied as well. Constant fold is an optimization that precomputes parts of the graph.</p>

<p>Before the Relay graph gets lowered to low level code, the Relay operators – e.g., relay.conv2d – get mapped to a high level tensor expression language. The corresponding LLVM IR gets generated from this.</p>

<h4 id="a-minimal-implementation-of-a-deep-learning-compiler">A minimal implementation of a deep learning compiler</h4>

<p>I built a deep learning compiler<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup> before having an idea of how the deep learning model graph was represented internally in the compiler but I think I guessed partly right. Here is the code that takes the following model and generates an AST:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Net</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">conv</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="nf">float</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">conv</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>
<p>Internally, in the AST the Conv2d is represented with this node:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Conv2dNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_tensor</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">input_height</span><span class="p">,</span> <span class="n">input_width</span><span class="p">,</span> <span class="n">filter_height</span><span class="p">,</span> <span class="n">filter_width</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">channels</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_tensor</span> <span class="o">=</span> <span class="n">input_tensor</span>
        <span class="n">self</span><span class="p">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span>
        <span class="n">self</span><span class="p">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">bias</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_height</span> <span class="o">=</span> <span class="n">input_height</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_width</span> <span class="o">=</span> <span class="n">input_width</span>
        <span class="n">self</span><span class="p">.</span><span class="n">filter_height</span> <span class="o">=</span> <span class="n">filter_height</span>
        <span class="n">self</span><span class="p">.</span><span class="n">filter_width</span> <span class="o">=</span> <span class="n">filter_width</span>
        <span class="n">self</span><span class="p">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
</code></pre></div></div>

<p>If you take a look at TVM’s Pytorch frontend which is defined <a href="https://github.com/apache/tvm/blob/main/python/tvm/relay/frontend/pytorch.py#L5282">here</a> in line 5282. If you scroll down to line <a href="https://github.com/apache/tvm/blob/main/python/tvm/relay/frontend/pytorch.py#L5360">5360</a> you will also notice how TVM gets the computational graph from a given Pytorch model.</p>

<p>Based on TVM’s implementation, I figured out the following implementation which takes a convolutional layer defined in Pytorch and gets the computational graph and generates C code.</p>

<p>Here is how I manipulated the computational graph. The idea of my solution was to combine the graph information obtained from <code class="language-plaintext highlighter-rouge">torch.jit.trace</code> and <code class="language-plaintext highlighter-rouge">torch.fx.symbolic_trace</code> to get the appropriate information about the graph such as operators in the layers and actual tensors.</p>

<p>I also had to experiment with TVM’s API and read the Pytorch documentation but once I was able to manipulate the operators and tensors I only had to figure out how a convolution operator is implemented and then write it in C as part of the runtime. But I do not think the convolutional kernel is pre-defined this way in TVM. Instead the code for the kernel is generated from a high level specificiation. Otherwise you would just be building a fraemwork like system.</p>

<p>Anyways, although I did not construct a DAG, I still created an abstract syntax tree to represent the deep learning model. Although a DAG can be constructed for a bigger model by not computing common sub-expressions. So, when a common sub-expression is reached, one that was already computed, we return the node. DAGs allow you to generate efficient code.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">torch_to_ast</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">input_tensor</span><span class="p">):</span>
	<span class="n">module</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">jit</span><span class="p">.</span><span class="nf">trace</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">input_tensor</span><span class="p">)</span>
	<span class="n">gm</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">fx</span><span class="p">.</span><span class="nf">symbolic_trace</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>
	<span class="n">layers</span> <span class="o">=</span> <span class="nf">get_layers</span><span class="p">(</span><span class="n">gm</span><span class="p">)</span>
	<span class="n">nodes</span> <span class="o">=</span> <span class="nc">ShapeProp</span><span class="p">(</span><span class="n">gm</span><span class="p">)</span>
	<span class="n">nodes</span><span class="p">.</span><span class="nf">propagate</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span>
    
	<span class="n">tensor_data</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">gm</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">nodes</span><span class="p">:</span>
    	<span class="n">tensor_data</span><span class="p">.</span><span class="nf">append</span><span class="p">({</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">:</span> <span class="n">node</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="sh">'</span><span class="s">dtype</span><span class="sh">'</span><span class="p">:</span> <span class="n">node</span><span class="p">.</span><span class="n">meta</span><span class="p">[</span><span class="sh">'</span><span class="s">tensor_meta</span><span class="sh">'</span><span class="p">].</span><span class="n">dtype</span><span class="p">,</span> <span class="sh">'</span><span class="s">shape</span><span class="sh">'</span><span class="p">:</span> <span class="n">node</span><span class="p">.</span><span class="n">meta</span><span class="p">[</span><span class="sh">'</span><span class="s">tensor_meta</span><span class="sh">'</span><span class="p">].</span><span class="n">shape</span><span class="p">,</span> <span class="sh">'</span><span class="s">tensor</span><span class="sh">'</span><span class="p">:</span> <span class="n">node</span><span class="p">.</span><span class="n">meta</span><span class="p">[</span><span class="sh">'</span><span class="s">tensor_meta</span><span class="sh">'</span><span class="p">].</span><span class="n">data</span><span class="p">})</span>

	<span class="n">layers_lst</span> <span class="o">=</span> <span class="p">[</span><span class="nf">list</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span> <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">]</span>

	<span class="n">layers</span> <span class="o">=</span> <span class="n">layers_lst</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

	<span class="n">layers</span> <span class="o">=</span> <span class="p">[{</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">:</span> <span class="n">layer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="sh">'</span><span class="s">nn_obj</span><span class="sh">'</span><span class="p">:</span> <span class="n">layer</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span> <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">]</span>

	<span class="n">ast_nodes</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)):</span>
    	<span class="n">nn_obj</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="sh">'</span><span class="s">nn_obj</span><span class="sh">'</span><span class="p">]</span>
    	<span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">nn_obj</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">modules</span><span class="p">.</span><span class="n">conv</span><span class="p">.</span><span class="n">Conv2d</span><span class="p">):</span>
        	<span class="n">input_tensor</span> <span class="o">=</span> <span class="bp">None</span>
        	<span class="n">weight_tensor</span> <span class="o">=</span> <span class="bp">None</span>
        	<span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">tensor_data</span><span class="p">:</span>
            	<span class="k">if</span> <span class="n">tensor</span><span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">]</span> <span class="o">==</span> <span class="sh">'</span><span class="s">x</span><span class="sh">'</span><span class="p">:</span>
                	<span class="n">input_tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="sh">'</span><span class="s">tensor</span><span class="sh">'</span><span class="p">]</span>
            	<span class="k">elif</span> <span class="n">tensor</span><span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">]</span> <span class="o">==</span> <span class="n">layers</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">]:</span>
                	<span class="n">input_name</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">]</span>
                	<span class="n">weight_tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="sh">'</span><span class="s">tensor</span><span class="sh">'</span><span class="p">]</span>
        	<span class="n">state_dict</span> <span class="o">=</span> <span class="n">module</span><span class="p">.</span><span class="nf">state_dict</span><span class="p">()</span>
        	<span class="n">bias_name</span> <span class="o">=</span> <span class="n">input_name</span> <span class="o">+</span> <span class="sh">"</span><span class="s">.bias</span><span class="sh">"</span>
        	<span class="n">weight</span> <span class="o">=</span> <span class="n">state_dict</span><span class="p">[</span><span class="n">input_name</span> <span class="o">+</span> <span class="sh">"</span><span class="s">.weight</span><span class="sh">"</span><span class="p">]</span>
        	<span class="n">bias_tensor</span> <span class="o">=</span> <span class="n">state_dict</span><span class="p">[</span><span class="n">bias_name</span><span class="p">]</span>
        	<span class="n">batch_size</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">input_height</span><span class="p">,</span> <span class="n">input_width</span> <span class="o">=</span> <span class="n">input_tensor</span><span class="p">.</span><span class="n">shape</span>
        	<span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span> <span class="n">filter_height</span><span class="p">,</span> <span class="n">filter_width</span> <span class="o">=</span> <span class="n">weight</span><span class="p">.</span><span class="n">shape</span>
        	<span class="n">bias</span> <span class="o">=</span> <span class="bp">None</span>
        	<span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">bias_tensor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nf">isinstance</span><span class="p">(</span><span class="nf">float</span><span class="p">(</span><span class="n">bias_tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">):</span>
            	<span class="n">bias</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="n">bias_tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        	<span class="k">else</span><span class="p">:</span>
            	<span class="n">bias</span> <span class="o">=</span> <span class="n">bias_tensor</span>
        	<span class="n">ast_nodes</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nc">Conv2dNode</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">input_height</span><span class="p">,</span> <span class="n">input_width</span><span class="p">,</span> <span class="n">filter_height</span><span class="p">,</span> <span class="n">filter_width</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">channels</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">ast_nodes</span>

<span class="k">def</span> <span class="nf">get_layers</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    
	<span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="nf">named_modules</span><span class="p">())</span>
</code></pre></div></div>

<p>And here is how I generated the C code.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            
<span class="k">def</span> <span class="nf">to_c</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Conv2dNode</span><span class="p">):</span>
        <span class="n">c_str</span> <span class="o">=</span> <span class="sh">"""</span><span class="s">
#include </span><span class="sh">"</span><span class="s">runtime.c</span><span class="sh">"</span><span class="s">
#include &lt;stdio.h&gt;

int main() {
</span><span class="sh">"""</span>
        <span class="n">bias</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">bias</span><span class="p">)</span>
        <span class="n">input_h</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">input_height</span><span class="p">)</span>
        <span class="n">input_w</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">input_width</span><span class="p">)</span>
        <span class="n">filter_h</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">filter_height</span><span class="p">)</span>
        <span class="n">filter_w</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">filter_width</span><span class="p">)</span>
        <span class="n">batch_s</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">channels</span><span class="p">)</span>

        <span class="n">tensor</span> <span class="o">=</span> <span class="nf">torch_tensor_to_c</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">input_tensor</span><span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="nf">torch_tensor_to_c</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span>
        
        <span class="n">c_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">    int batch_size = </span><span class="si">{</span><span class="nf">str</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">batch_s</span><span class="p">))</span><span class="si">}</span><span class="s">;</span><span class="se">\n</span><span class="sh">"</span>
        <span class="n">c_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">    int channels = </span><span class="si">{</span><span class="nf">str</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">channels</span><span class="p">))</span><span class="si">}</span><span class="s">;</span><span class="se">\n</span><span class="sh">"</span>
        <span class="n">c_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">    int input_height = </span><span class="si">{</span><span class="nf">str</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">input_h</span><span class="p">))</span><span class="si">}</span><span class="s">;</span><span class="se">\n</span><span class="sh">"</span>
        <span class="n">c_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">    int input_width = </span><span class="si">{</span><span class="nf">str</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">input_w</span><span class="p">))</span><span class="si">}</span><span class="s">;</span><span class="se">\n</span><span class="sh">"</span>
        <span class="n">c_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">    int filter_height = </span><span class="si">{</span><span class="nf">str</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">filter_h</span><span class="p">))</span><span class="si">}</span><span class="s">;</span><span class="se">\n</span><span class="sh">"</span>
        <span class="n">c_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">    int filter_width = </span><span class="si">{</span><span class="nf">str</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">filter_w</span><span class="p">))</span><span class="si">}</span><span class="s">;</span><span class="se">\n</span><span class="sh">"</span>
        
        <span class="n">c_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">    float input_data[</span><span class="si">{</span><span class="n">batch_s</span><span class="si">}</span><span class="s">][</span><span class="si">{</span><span class="n">channels</span><span class="si">}</span><span class="s">][</span><span class="si">{</span><span class="n">input_h</span><span class="si">}</span><span class="s">][</span><span class="si">{</span><span class="n">input_w</span><span class="si">}</span><span class="s">] = </span><span class="si">{</span><span class="n">tensor</span><span class="si">}</span><span class="s">;</span><span class="se">\n</span><span class="sh">"</span>
        <span class="n">c_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">    float weight[</span><span class="si">{</span><span class="n">batch_s</span><span class="si">}</span><span class="s">][</span><span class="si">{</span><span class="n">channels</span><span class="si">}</span><span class="s">][</span><span class="si">{</span><span class="n">filter_h</span><span class="si">}</span><span class="s">][</span><span class="si">{</span><span class="n">filter_w</span><span class="si">}</span><span class="s">] = </span><span class="si">{</span><span class="n">weight</span><span class="si">}</span><span class="s">;</span><span class="se">\n</span><span class="sh">"</span>
        <span class="n">c_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">    float bias = </span><span class="si">{</span><span class="n">bias</span><span class="si">}</span><span class="s">;</span><span class="se">\n</span><span class="sh">"</span>
        <span class="n">c_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">    float output[</span><span class="si">{</span><span class="n">batch_s</span><span class="si">}</span><span class="s">][</span><span class="si">{</span><span class="n">channels</span><span class="si">}</span><span class="s">][</span><span class="si">{</span><span class="n">filter_h</span><span class="si">}</span><span class="s">][</span><span class="si">{</span><span class="n">filter_h</span><span class="si">}</span><span class="s">];</span><span class="se">\n</span><span class="sh">"</span>
        
        <span class="n">c_str</span> <span class="o">+=</span> <span class="sh">"""</span><span class="s">
    convolution(input_data, weight, &amp;bias, batch_size, channels, input_height, input_width, filter_height, filter_width, output);

    printf(</span><span class="sh">"</span><span class="s">%f</span><span class="sh">"</span><span class="s">, output[0][0][0][0]);
       
    return 0;
}
</span><span class="sh">"""</span>
        <span class="k">return</span> <span class="n">c_str</span>

<span class="k">def</span> <span class="nf">torch_tensor_to_c</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
    <span class="n">c_array</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">.</span><span class="nf">numpy</span><span class="p">().</span><span class="nf">tolist</span><span class="p">()</span>
    <span class="n">c_array</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">c_array</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="sh">'</span><span class="s">[</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">{</span><span class="sh">'</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="sh">'</span><span class="s">]</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c_array</span>
</code></pre></div></div>

<p>And here is the C code that my compiler generates for the above neural net:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"runtime.c"</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">channels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">input_height</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">input_width</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">filter_height</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">filter_width</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">input_data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{{{</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">}}}};</span>
    <span class="kt">float</span> <span class="n">weight</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{{{</span><span class="mi">0</span><span class="p">.</span><span class="mi">1206025704741478</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2804994285106659</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">10350386798381805</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">31444603204727173</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">3109368085861206</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">22286033630371094</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">12215566635131836</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2765805721282959</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25621065497398376</span><span class="p">}}}};</span>
    <span class="kt">float</span> <span class="n">bias</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">24808375537395477</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>

    <span class="n">convolution</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bias</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">input_height</span><span class="p">,</span> <span class="n">input_width</span><span class="p">,</span> <span class="n">filter_height</span><span class="p">,</span> <span class="n">filter_width</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%f"</span><span class="p">,</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
       
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="how-to-improve-it">How to improve it</h3>

<p>I have plans to keep working on this compiler but I need to study TVM more. Next, I want to compile a VGG block to C code. Now, we can manually write some of the optimizations that compilers use to help GCC generate faster code. And we can also generate vectorized C code. In the paper “Achieving high performance the functional way”<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>, the authors observed that the approach taken in the construction of TVM is limited. The way the schedule and algorithm is seperated in TVM is limited because the users cannot formulate their own abstractons. TVM’s API is not extensible; moreover, the authors observed that often its not sufficient to soley change the optimizations. Instead you also need to change the algorithm. So, TVM is not extensible. Instead, the authors proposed two DSLs that allow users to formulate their own schedules without changing the algorithm. I think, the key here is that by making the system more extensible you give more power to the user since the user does not have to modify the compiler itself.</p>

<p>Speaking of extensibility, my conjecture is that this approach can be improved even more by building a DSL in Common Lisp. With the power of macros we can construct a DSL that inherits the whole Lisp language which will make such system even more extensible. Users can make new macros to extend the language and add new algorithms and schedules thereby extending the language to fit their needs. Common Lisp (SBCL) is a high performant language and is highly extensible; moreover, the standard library has functionality for SIMD instructions and as a result if we were to build a system in Lisp we could just generate Lisp with SIMD instructions enabled.</p>

<h3 id="summary">Summary</h3>

<p>Hopefully, you have a better idea of how, at least, a minimal deep learning compiler works in practice. I left out the optimizations but you can learn more about the optimizations from the “The Deep Learning Compiler: A Comprehensive Survey” that is listed in the references. The basic idea is that given a deep learning model defined in Pytorch, the first thing to do is build the computational graph consisting of deep learning operators such as convolution and the tensors. Once you have the graph then you apply machine independent optimizations. After this you  build a low level IR to which machine dependent optimizations are applied and finally you generate the code.</p>

<h3 id="some-relevant-further-reading">Some relevant further reading</h3>

<p>If you want to explore this further I recommend the repo: <a href="https://github.com/merrymercy/awesome-tensor-compilers">Awesome Tensor Compilers</a>.</p>

<p>Specifically, from that list, the Tiramisu, TVM, and Hidet papers are very good.</p>

<h3 id="references">References</h3>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://arxiv.org/pdf/2002.03794.pdf">The Deep Learning Compiler</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><a href="https://huyenchip.com/2021/09/07/a-friendly-introduction-to-machine-learning-compilers-and-optimizers.html">A Friendly Introduction to Machine Learning Compilers and Optimizers</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p><a href="https://tvm.apache.org/docs/v0.9.0/arch/relay_intro.html">Relay IR</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:3:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p><a href="https://www.usenix.org/system/files/osdi18-chen.pdf">The TVM Paper</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:4:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p><a href="https://github.com/Jobhdez/Convy">My Deep Learning compiler</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p><a href="https://dl.acm.org/doi/pdf/10.1145/3408974">Achieving High Performance the functional way</a> <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Job Hernandez Lara</name></author><category term="compilers" /></entry><entry><title type="html">How to deploy a Lisp server to AWS</title><link href="http://localhost:4000/2024/01/17/how-to-deploy-lisp.html" rel="alternate" type="text/html" title="How to deploy a Lisp server to AWS" /><published>2024-01-17T00:00:00-08:00</published><updated>2024-01-17T00:00:00-08:00</updated><id>http://localhost:4000/2024/01/17/how-to-deploy-lisp</id><content type="html" xml:base="http://localhost:4000/2024/01/17/how-to-deploy-lisp.html"><![CDATA[<h3 id="intoduction">Intoduction</h3>

<p>I have been programming server side programs with Lisp and the Hunchentoot web server for a while. I am writing this blog post as a future reminder for myself and help anybody out there with the basics.</p>

<p>The way I managed to deploy my Lisp server was by using docker and building the image within the EC2 instance. Once you run the image you  navigate to the EC2 instance’s public IP and you will see your server there.</p>

<p>But some disclaimers:</p>

<p>My friend who has around 20 years of experience and is really good said that for production you probably do not need to manage docker yourself. This is what he said:</p>

<blockquote>
  <p>specifically the thing that makes it not for production is that you probably don’t want to be managing docker yourself on an ec2 instance. It’s not completely out of the question if you really really know what you’re doing, but you need to deal with things like the ec2 instance rebooting, or the process crashing, or the docker host process crashing.
ECS and EKS are services (one native to amazon, the other using kubernetes) that will manage a lot of that for you and more</p>
</blockquote>

<p>The problem with this is that if you use this approach for an app that cannot go down then if the EC2 instance restarts your app will be down because you have type <code class="language-plaintext highlighter-rouge">docker run</code> to restart your server again. But since my app is not critical I used an EC2 instance.</p>

<p>My friend did offer an alternative:</p>

<blockquote>
  <p>next time around, rather than using ec2 at all, I would push the image to ecr (its a private image repository) and then build an ecs instance that starts that image - that way you don’t have to worry about docker at all beyond builiding the image</p>
</blockquote>

<h3 id="the-dockerfile">The Dockerfile</h3>
<p>I happened to stumble accross this <a href="https://www.youtube.com/watch?v=QuG2ByK-Cwg&amp;t=390s">video</a> and I was able to make the following Dockerfile for my project:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM clfoundation/sbcl:alpine3.14 as builder

COPY . /root/common-lisp/
WORKDIR /root/common-lisp/

# https://www.reddit.com/r/Common_Lisp/comments/pdsqbe/installing_quicklisp/
# https://github.com/yitzchak/common-lisp-jupyter/blob/master/Dockerfile
ENV QUICKLISP_ADD_TO_INIT_FILE=true
RUN sbcl --non-interactive --load quicklisp2.lisp \
      --eval "(quicklisp-quickstart:install)" \
      --eval "(ql-util:without-prompting (ql:add-to-init-file))"

RUN sbcl --eval "(ql:quickload :compiler-web)" \
         --load server.lisp \
         --eval "(sb-ext:save-lisp-and-die \"core\" :toplevel #'lambda-server::start-server :executable t)"

FROM clfoundation/sbcl:alpine3.14

RUN adduser -D app
USER app

COPY --from=builder /root/common-lisp/core .

EXPOSE 4243

ENTRYPOINT [ "sbcl", "--core", "core" ]
</code></pre></div></div>

<p>You are going to have to change the package name in</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RUN sbcl --eval "(ql:quickload :compiler-web)" \
         --load server.lisp \
         --eval "(sb-ext:save-lisp-and-die \"core\" :toplevel #'lambda-server::start-server :executable t)"
</code></pre></div></div>

<p>and load your server and replace <code class="language-plaintext highlighter-rouge">'lambda-server::start-server</code> with your function that starts the server. Other than that you can keep it as it is. You also need to change <code class="language-plaintext highlighter-rouge">EXPOSE 4243</code> to <code class="language-plaintext highlighter-rouge">EXPOSE &lt;your-lisp-server-port&gt;</code>.</p>

<h3 id="ec2">EC2</h3>

<p>Once you have the Dockerfile you then need to make an AWS account and launch an EC2 instance. You should keep it within the free tier limits and use a linux instance.</p>

<p>Once you have launched the EC2 instance you need to install git and docker:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* sudo yum update -y
* sudo yum install docker -y
* sudo service docker start
* sudo usermod -a -G docker ec2-user
* sudo yum install git -y
</code></pre></div></div>

<p>Now, you need to clone your github repo from the EC2 instance.</p>

<p>Your repo should contain a <code class="language-plaintext highlighter-rouge">Dockerfile</code>.</p>

<p>Then you need to build it so you need to move to your repo’s directory and type:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* sudo docker build -t compiler-web .
* sudo docker run -p 80:4243 --rm compiler-web
</code></pre></div></div>

<p>By doing <code class="language-plaintext highlighter-rouge">-t</code> you are tagging your image. In my case the tag for my image is <code class="language-plaintext highlighter-rouge">compiler-web</code>. You can change this as you wish. My Lisp server is listening at the port <code class="language-plaintext highlighter-rouge">4243</code> so you need to change this to your port. But keep the port 80 since this the port of your EC2 instance I believe.</p>

<p>After trying to rebuild your image again you may get a cache error. To solve this you can build it like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* sudo docker build --no-cache -t compiler-web .
</code></pre></div></div>

<p>After you have built the docker image you just need to point to the EC2’s public IP and you should be able to see your server.</p>

<p>To deploy, you need to setup an Elastic IP within your EC2 instance and then associate the Elastic IP to an A record, in your domain provider’s DNS settings, with a <code class="language-plaintext highlighter-rouge">@</code>. After this you just wait until the changes propagates.</p>

<h3 id="conclusion">Conclusion</h3>

<p>I hope this was helpful :-). Have a nice day.</p>]]></content><author><name>Job Hernandez</name></author><category term="aws" /><category term="how-to" /><summary type="html"><![CDATA[Intoduction]]></summary></entry><entry><title type="html">The computational model behind interpreters</title><link href="http://localhost:4000/2023/12/31/computational-models.html" rel="alternate" type="text/html" title="The computational model behind interpreters" /><published>2023-12-31T00:00:00-08:00</published><updated>2023-12-31T00:00:00-08:00</updated><id>http://localhost:4000/2023/12/31/computational-models</id><content type="html" xml:base="http://localhost:4000/2023/12/31/computational-models.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#background" id="markdown-toc-background">Background</a></li>
  <li><a href="#models-for-computation" id="markdown-toc-models-for-computation">Models for computation</a>    <ul>
      <li><a href="#interpreters-are-implementation-of-the-environment-model-for-computation" id="markdown-toc-interpreters-are-implementation-of-the-environment-model-for-computation">Interpreters are implementation of the environment model for computation</a>        <ul>
          <li><a href="#a-scheme-interpreter-implementation" id="markdown-toc-a-scheme-interpreter-implementation">A Scheme interpreter implementation</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
</ul>

<h3 id="introduction">Introduction</h3>

<p>In this blog post I will explain what the substitution model for computation is which is associated with pure functional programming and then I explain how, when assignment and mutation are added,  the substitution model no longer holds. As a result, a different model for computation is needed, namely, the environment model for computation whereby expressions get evaluated in the context of an environment. I culminate the blog by sharing part of the scheme interpreter I built which is an implementation of the environment model. CPython also uses this environment model to carry out its computations; moreover, I also point out that a scheme interpreter built using a Python interpreter shows what it means to compute something in the sense of a universal machine.</p>

<h3 id="background">Background</h3>
<p>In “Structure and Interpretation of Computer Programs” it talks about the deep meaning of what an interpreter is. An interpreter can be seen as a universal machine that emulates other machines.</p>

<p>Interpreters compute anything that in principle can be computed, i.e. an interpreter is a universal machine; for example, if you feed a C interpreter to a Scheme interpreter the Scheme interpreter can emulate the C interpreter and thereby compute any C program.</p>

<blockquote>
  <p>The deep idea here is that any evaluator can emulate any other. Thus, the notion of “what can in principle be computed” (ignoring practicalities of time and memory required) is independent of the language or the computer and instead reflects an underlying notion of computability.</p>
</blockquote>

<p>To illustrate what this quote is saying, suppose we give the Python3 interpreter a Scheme interpreter. As a consequence, the Python3 interpreter will mimic a Scheme interpreter which in turn will compute any Scheme expression. So, computation is universal.</p>

<p>In what follows I will try to explain the environment model for  computation. The environment model for computation is the ground for interpreters. And we will conclude with a Scheme interpreter implemented in Python.</p>

<h3 id="models-for-computation">Models for computation</h3>

<p>In “Structure and Interpretation of Computer Programs” it talks about at least two computational models; one is associated with pure functional programming and one with programming with assignment/mutation. These computational models are the <strong>substitution model</strong> and <strong>environment model</strong>.</p>

<p>Both models are about how expressions get evaluated.</p>

<p>In the substitution model, each element of an expression is another expression including the operator. So, the way the substitution model works is by evaluating each expression and then applying the operator to the operands.</p>

<p>Suppose you have the following Scheme program:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">sum-of-squares</span> <span class="nv">e</span> <span class="nv">e2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">e2</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">e</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">*</span> <span class="nv">e</span> <span class="nv">e</span><span class="p">))</span>
</code></pre></div></div>

<p>To evaluate this you will go through the following process:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">sum-of-squares</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">;; -&gt;</span>
<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1">;; -&gt;</span>
<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1">;; -&gt;</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">9</span> <span class="mi">16</span><span class="p">)</span>
<span class="c1">;; -&gt;</span>
<span class="mi">25</span>
</code></pre></div></div>

<p>A property of such model is <strong>referential transparency</strong>. A program is said to be referentially transparent if one function definition can be substituted for another one and still evaluate to the same value.</p>

<p>Consider the following:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">p1</span> <span class="nv">sum-of-squares</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">p2</span> <span class="nv">sum-of-squares</span><span class="p">)</span>

<span class="p">(</span><span class="nf">p1</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">;; -&gt;</span>
<span class="mi">25</span>

<span class="p">(</span><span class="nf">p2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">;; -&gt;</span>
<span class="mi">25</span>
</code></pre></div></div>

<p>In the above example, the function <code class="language-plaintext highlighter-rouge">p1</code> can be substituted with <code class="language-plaintext highlighter-rouge">p2</code> at any time and get the same result.</p>

<p>But what happens when you introduce mutation? If you introduce mutation does referential transparency still hold?</p>

<p>Consider the following two programs taken from SICP:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">make-simplified-withdraw</span> <span class="nv">balance</span><span class="p">)</span>
   <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">amount</span><span class="p">)</span>
     <span class="p">(</span><span class="k">set!</span> <span class="nv">balance</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">make-decrementer</span> <span class="nv">balance</span><span class="p">)</span>
   <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">amount</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">-</span> <span class="nv">balance</span> <span class="nv">amount</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">w1</span> <span class="p">(</span><span class="nf">make-simplified-withdraw</span> <span class="mi">25</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">d1</span> <span class="p">(</span><span class="nf">make-decrementer</span> <span class="mi">25</span><span class="p">))</span>

<span class="p">(</span><span class="nf">w1</span> <span class="mi">10</span><span class="p">)</span>
<span class="c1">;; -&gt;</span>
<span class="mi">15</span>
<span class="p">(</span><span class="nf">w1</span> <span class="mi">10</span><span class="p">)</span>
<span class="c1">;; -&gt;</span>
<span class="mi">5</span>

<span class="c1">;; the following adheres to the substitution model</span>
<span class="p">(</span><span class="nf">d1</span> <span class="mi">10</span><span class="p">)</span>
<span class="c1">;; -&gt;</span>
<span class="mi">15</span>
<span class="p">(</span><span class="nf">d1</span> <span class="mi">10</span><span class="p">)</span>
<span class="c1">;; -&gt;</span>
<span class="mi">15</span>
</code></pre></div></div>
<p>For the first example, since the substitution model does not hold anymore then we must talk about the <strong>environment model</strong> of computation.</p>

<p>In the environment model for computation a variable is not just a name for a value; instead, a variable implies a container. This container is called an <strong>environment</strong>. In this model, to evaluate a program you must also evaluate the operator and operand but you need to do this within an environment. When an assignment is being evaluated the interpreter must look up the value for the variable in an environment.</p>

<p>To evaluate procedures we must evaluate it in the context of the global environment and also within its local environment.</p>

<p>So, my point is that the deep computational idea behind interpreters is grounded on the environment model of computation. The environment model of computation is indeed the model that is used to implement interpreters.</p>

<h4 id="interpreters-are-implementation-of-the-environment-model-for-computation">Interpreters are implementation of the environment model for computation</h4>

<p>A Scheme interpreter or a Python interpreter or any other interpreter in general are implementations of the environment model for computation.</p>

<p>Evaluating or interpreting  programs is a process which consists of evaluating an expression in the context of an environment.</p>

<p>For example, here is an example of the environment for my Scheme interpreter:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Env</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">(),</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">outer</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">outer</span> <span class="o">=</span> <span class="n">outer</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">outer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">outer</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">NameError</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Variable </span><span class="sh">'</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="sh">'</span><span class="s"> is not defined.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>And as I said above, when you introduce mutation and assignment, the substitution model no longer holds, and as a consequence, a variable is no longer just a definition. Instead a variable implies an environment. As you can see here:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">global_env</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">exp</span><span class="p">:</span>
        <span class="c1">#....
</span>	<span class="n">case</span> <span class="nc">SetBang</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
            <span class="n">env</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">var</span><span class="p">.</span><span class="n">var</span><span class="p">)[</span><span class="n">var</span><span class="p">.</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>

<p>Procedures are evaluated within an environment but a procedure needs to consider the global environment and an environment that is local to it. An example of this is the following code of this implementation:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Procedure</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">params</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">body</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">env</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">interp</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">body</span><span class="p">,</span> <span class="nc">Env</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">params</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">env</span><span class="p">))</span>
</code></pre></div></div>

<h5 id="a-scheme-interpreter-implementation">A Scheme interpreter implementation</h5>

<p>As an example take a look at the following <a href="https://github.com/Jobhdez/schemy">Scheme interpreter</a> I built with Python. This example shows how a Python interpreter can emulate a Scheme interpreter which can compute any Scheme expression.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Env</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">(),</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">outer</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">outer</span> <span class="o">=</span> <span class="n">outer</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">outer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">outer</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">NameError</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Variable </span><span class="sh">'</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="sh">'</span><span class="s"> is not defined.</span><span class="sh">"</span><span class="p">)</span>
    
<span class="k">class</span> <span class="nc">Procedure</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">params</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">body</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">env</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">interp</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">body</span><span class="p">,</span> <span class="nc">Env</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">params</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">env</span><span class="p">))</span>
	
<span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">global_env</span><span class="p">):</span>

    <span class="n">match</span> <span class="n">exp</span><span class="p">:</span>
        <span class="n">case</span> <span class="nc">Exps</span><span class="p">(</span><span class="n">exps</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">exps</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nf">interp</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        
        <span class="n">case</span> <span class="nc">Exp</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="k">return</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        
        <span class="n">case</span> <span class="nc">Bool</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">b</span>
        
        <span class="n">case</span> <span class="nc">If</span><span class="p">(</span><span class="n">cnd</span><span class="p">,</span> <span class="n">thn</span><span class="p">,</span> <span class="n">els</span><span class="p">):</span>
            <span class="n">match</span> <span class="nf">interp</span><span class="p">(</span><span class="n">cnd</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
                <span class="n">case</span> <span class="sh">"</span><span class="s">#t</span><span class="sh">"</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nf">interp</span><span class="p">(</span><span class="n">thn</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
                <span class="n">case</span> <span class="sh">"</span><span class="s">#f</span><span class="sh">"</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nf">interp</span><span class="p">(</span><span class="n">els</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
                
        <span class="n">case</span> <span class="nc">Prim</span><span class="p">(</span><span class="nc">Op</span><span class="p">(</span><span class="n">oper</span><span class="p">),</span> <span class="n">e</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
            <span class="n">match</span> <span class="n">oper</span><span class="p">:</span>
                <span class="n">case</span> <span class="sh">'</span><span class="s">and</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">match</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
                        <span class="n">case</span> <span class="sh">'</span><span class="s">#t</span><span class="sh">'</span><span class="p">:</span>
                            <span class="n">match</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
                                <span class="n">case</span> <span class="sh">'</span><span class="s">#t</span><span class="sh">'</span><span class="p">:</span>
                                    <span class="k">return</span> <span class="sh">'</span><span class="s">#t</span><span class="sh">'</span>
                                <span class="n">case</span> <span class="sh">'</span><span class="s">#f</span><span class="sh">'</span><span class="p">:</span>
                                    <span class="k">return</span> <span class="sh">'</span><span class="s">#f</span><span class="sh">'</span>
                        <span class="n">case</span> <span class="sh">'</span><span class="s">#f</span><span class="sh">'</span><span class="p">:</span>
                            <span class="k">return</span> <span class="sh">'</span><span class="s">#f</span><span class="sh">'</span>
                        
                <span class="n">case</span> <span class="sh">'</span><span class="s">or</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">match</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
                        <span class="n">case</span> <span class="sh">'</span><span class="s">#t</span><span class="sh">'</span><span class="p">:</span>
                            <span class="k">return</span> <span class="sh">'</span><span class="s">#t</span><span class="sh">'</span>
                        <span class="n">case</span> <span class="sh">'</span><span class="s">#f</span><span class="sh">'</span><span class="p">:</span>
                            <span class="n">match</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
                                <span class="n">case</span> <span class="sh">'</span><span class="s">#t</span><span class="sh">'</span><span class="p">:</span>
                                    <span class="k">return</span> <span class="sh">'</span><span class="s">#t</span><span class="sh">'</span>
                                <span class="n">case</span> <span class="sh">'</span><span class="s">#f</span><span class="sh">'</span><span class="p">:</span>
                                    <span class="k">return</span> <span class="sh">'</span><span class="s">#f</span><span class="sh">'</span>
                                
                <span class="n">case</span> <span class="sh">'</span><span class="s">+</span><span class="sh">'</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="o">+</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
                
                <span class="n">case</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="o">-</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>

                <span class="n">case</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="o">*</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>

                <span class="n">case</span> <span class="sh">'</span><span class="s">=</span><span class="sh">'</span><span class="p">:</span>
                    <span class="k">return</span> <span class="sh">'</span><span class="s">#t</span><span class="sh">'</span> <span class="k">if</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="o">==</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="k">else</span> <span class="sh">'</span><span class="s">#f</span><span class="sh">'</span>
        <span class="n">case</span> <span class="nc">Int</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">n</span>
        
        <span class="n">case</span> <span class="nc">Var</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">env</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="n">e</span><span class="p">]</span>
        
        <span class="n">case</span> <span class="nc">Let</span><span class="p">(</span><span class="nc">Binding</span><span class="p">(</span><span class="nc">Var</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="n">e</span><span class="p">),</span> <span class="n">body_exp</span><span class="p">):</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="nc">Procedure</span><span class="p">([</span><span class="n">var</span><span class="p">],</span> <span class="n">body_exp</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
            <span class="n">exps</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="nf">interp</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">exps</span><span class="p">]</span>

            <span class="k">return</span> <span class="nf">proc</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">)</span>
        
        <span class="n">case</span> <span class="nc">SetBang</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
            <span class="n">env</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">var</span><span class="p">.</span><span class="n">var</span><span class="p">)[</span><span class="n">var</span><span class="p">.</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="nf">interp</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
            
        <span class="n">case</span> <span class="nc">Begin</span><span class="p">(</span><span class="n">exps</span><span class="p">):</span>
            <span class="n">flat_expressions</span> <span class="o">=</span> <span class="nf">flatten_exps</span><span class="p">(</span><span class="n">exps</span><span class="p">)</span>
            <span class="n">expressions</span> <span class="o">=</span> <span class="n">flat_expressions</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
                <span class="nf">interp</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>

            <span class="k">return</span> <span class="nf">interp</span><span class="p">(</span><span class="n">flat_expressions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">env</span><span class="p">)</span>

        <span class="n">case</span> <span class="nc">Define</span><span class="p">(</span><span class="nc">Var</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="n">exp</span><span class="p">):</span>
            <span class="n">env</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="nf">interp</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>

        <span class="n">case</span> <span class="nc">Lambda</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="nf">flatten_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

            <span class="k">return</span> <span class="nc">Procedure</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>

        <span class="n">case</span> <span class="nc">Application</span><span class="p">(</span><span class="n">exps</span><span class="p">):</span>
            <span class="n">exps</span> <span class="o">=</span> <span class="nf">flatten_exps</span><span class="p">(</span><span class="n">exps</span><span class="p">)</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="nf">interp</span><span class="p">(</span><span class="n">exps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">env</span><span class="p">)</span>
            <span class="n">exps</span> <span class="o">=</span> <span class="n">exps</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="nf">interp</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">exps</span><span class="p">]</span>

            <span class="k">return</span> <span class="nf">operator</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">)</span>
            
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Parse node </span><span class="si">{</span><span class="n">exp</span><span class="si">}</span><span class="s"> is not valid node.</span><span class="sh">'</span><span class="p">)</span>

</code></pre></div></div>

<h3 id="conclusion">Conclusion</h3>

<p>In conclusion, I have tried to illustrate two models for computation, one of which, the evaluation model, is the ground for the deep idea about computation underlying interpreters. I hope this was helpful. Thanks.</p>]]></content><author><name>Job Hernandez Lara</name></author><category term="lisp" /><category term="compilers" /><category term="computer-science" /></entry><entry><title type="html">A semi deep dive into CPU architecture</title><link href="http://localhost:4000/2023/11/05/a-semi-deep-dive-into-cpu-architecture.html" rel="alternate" type="text/html" title="A semi deep dive into CPU architecture" /><published>2023-11-05T00:00:00-07:00</published><updated>2023-11-05T00:00:00-07:00</updated><id>http://localhost:4000/2023/11/05/a-semi-deep-dive-into-cpu-architecture</id><content type="html" xml:base="http://localhost:4000/2023/11/05/a-semi-deep-dive-into-cpu-architecture.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#exposing-the-x86-architecture" id="markdown-toc-exposing-the-x86-architecture">Exposing the x86 architecture</a></li>
  <li><a href="#how-the-processor-executes-instructions" id="markdown-toc-how-the-processor-executes-instructions">How the processor executes instructions</a>    <ul>
      <li><a href="#clock-cycles" id="markdown-toc-clock-cycles">Clock cycles</a></li>
      <li><a href="#instruction-parallelism" id="markdown-toc-instruction-parallelism">Instruction parallelism</a></li>
    </ul>
  </li>
  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
</ul>

<h3 id="introduction">Introduction</h3>

<p>My compiler journey has made me curious about computer architecture; for example, I would like to know the x86 processor better. A great way to get close to the machine is by writing compilers because you get to lower high level programs to assembly. Assembly exposes the CPU and as a consequence you get to know the CPU better.</p>

<p>I am not an expert but in what follows I try to give you an idea of how the architecture of a CPU. I first try to expose the x86 architecture by demonstrating how core imperative constructs such as loops and arrays and if statements get represented in x86 assembly. Subsequently, I talk about the low level details.</p>

<p>Hopefully, you enjoy this!</p>

<h3 id="exposing-the-x86-architecture">Exposing the x86 architecture</h3>

<p>x86 assembly exposes the registers of the x86 architecture and the program counter. The program counter is the address of the next instruction to be executed. When using memory addresses instead of registers these memory addresses are actually part of the virtual memory address space.</p>

<p>The program counter is called <code class="language-plaintext highlighter-rouge">%rip</code> in x86-64. The register file of x86-64 consists of 16 named locations storing 64 bit values i.e., registers.</p>

<p>The register <code class="language-plaintext highlighter-rouge">%rsp</code> is the stack pointer, which indicates the end position of the run time stack. The top of the stack contains the lowest addresses. The <code class="language-plaintext highlighter-rouge">pushq</code> instruction pushes values to the stack and <code class="language-plaintext highlighter-rouge">popq</code> pops them. The stack follows a last in, first out operation; for example, suppose you have two variables each of which are a byte in size (i.e., quad word values). Pushing these values to the stack would consist of decrementing the stack pointer by 16:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> pushq %rbp
 movq %rsp, %rbp
 subq $16, %rsp
</code></pre></div></div>

<p>The operands of the instructions defined by the ISA consist of immediates, stack locations, and registers. Immediates are data such as numbers, stack locations are memory locations and registers are locations that can be accessed by the processor in a few cycles.</p>

<p>To get to know the x86-64 architecture a little bit more I will talk about how core imperative programming features get implemented in x86-64 assembly where core features include arrays, loops, and if statements.</p>

<p>First, lets expose the x86 architecture when its executing <code class="language-plaintext highlighter-rouge">if statements</code>.</p>

<p>Consider the following program:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="mi">3</span><span class="o">=</span><span class="mi">3</span><span class="p">:</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">+</span> <span class="o">-</span><span class="mi">5</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
  <span class="n">y</span> <span class="o">=</span> <span class="mi">25</span> <span class="o">+</span> <span class="o">-</span><span class="mi">10</span>
</code></pre></div></div>

<p>Lets expose immediates and stack locations and the stack pointer register <code class="language-plaintext highlighter-rouge">%rsp</code> by lowering the above program to x86 assembly. Remember some of the operands in x86 instructions are stack locations and immediates.</p>

<pre><code class="language-asm">.globl main

main:
      pushq %rbp
      movq %rsp, %rbp
      subq $16, %rsp     // the stack grows by decrementing the stack
      movq $3, -8(%rbp)  // move 5 into stack location 1
      cmp  $3, -8(%rbp)  // compare: 3 is not equal to 5
      je block_1
      jmp block_2

block_1:
      movq $5, -8(%rbp)
      negq -8(%rbp)
      movq -8(%rbp), %rax
      movq $30, -16(%rbp)
      addq -16(%rbp), %rax
      movq %rax, %rdi
      callq print_int
      addq $16, %rsp
      popq %rbp
      retq

block_2:
      movq $10, -8(%rbp)
      negq -8(%rbp)
      movq -8(%rbp), %rax
      movq $25, -16(%rbp)
      addq -16(%rbp), %rax
      movq %rax, %rdi
      callq print_int
      addq $16, %rsp
      popq %rbp
      retq

</code></pre>

<p>The first three instructions in the <code class="language-plaintext highlighter-rouge">main</code> block sets up the stack. It prepares the stack for the two variables and corresponding two stack locations.</p>

<p>In the background the compiler lowers the <code class="language-plaintext highlighter-rouge">x = 30 + -5</code> into</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tmp = -5
x = 30 + tmp
</code></pre></div></div>

<p>So it first needs to move 5 to a stack location, make it negative, move 30 to stack location 2 and then add them together and put the result in <code class="language-plaintext highlighter-rouge">%rax</code>.</p>

<p>It does the same thing for block 2.</p>

<p>Now, lets expose the registers and arrays and loops.</p>

<p>Suppose you have the following program:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
   <span class="nf">print</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>The x86 assembly for this code would look something like this:</p>

<pre><code class="language-asm">.section .data

array:
	.quad 1,2,3,4,5
	.section .text
    
	.globl main
    
main:
	leaq array(%rip), %rbx 
	movq $0, %r15   	// initializes i to 0
	jmp test

body:
    
	movq (%rbx, %r15, 8), %rdi     
	addq $2, %rdi // this adds two to a[i]    
	callq print_int // it prints a[i] + 2
	incq %r15 // increments i by 1
	jmp test

test:
	cmpq $5, %r15 // if i &gt; 5 (size of array) go to body; otherwise exit
	jne body
	jmp exit

exit:
	retq
	
</code></pre>

<p>The instruction <code class="language-plaintext highlighter-rouge">leaq array(%rip), %rbx</code> uses the stack pointer to get the address of the array and stores it in the register <code class="language-plaintext highlighter-rouge">rbx</code>.</p>

<p>On the other hand the instruction <code class="language-plaintext highlighter-rouge">movq (%rbx, %r15, 8), %rdi</code> uses the address of the array, the initialization of i which is in register <code class="language-plaintext highlighter-rouge">%r15</code> and the size of the data in bits. Each element of the array is a byte in size. With this instruction you are getting <code class="language-plaintext highlighter-rouge">array[i]</code>. This essentially is equivalent to <code class="language-plaintext highlighter-rouge">xA + L * i</code> where <code class="language-plaintext highlighter-rouge">xA</code> is a pointer to the starting location of the array, L is the size of data type L.</p>

<h3 id="how-the-processor-executes-instructions">How the processor executes instructions</h3>

<p>Now, lets talk about how the cpu executes instructions.</p>

<p>The processor consists of the control unit, the arithmetic logic unit, and a set of registers; the control unit is responsible for fetching instructions from main memory, the ALU is responsible for doing arithmetic and the registers hold the ALU input. The registers feed into ALU input registers which hold the ALU input while the ALU is performing some computation. There are also the ALU output registers which hold the output of the ALU and whose data can be sent to registers again or written to memory. How does the cpu carry out the instructions? The most important registers are the program counter and instruction register. The program counter points to the next instruction and the instruction register holds the current instruction that is being executed. The \(\textit{data path}\) consists of the ALU and registers; the registers feed into two input registers that hold the ALU input while the ALU is carrying out some computation; in turn these input registers are connected to the ALU. After the ALU finishes the computation it yields the output that gets stored in an ALU output register which in turn can go back to a register or later on stored in memory; the layered structure is as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>registers -&gt; ALU input registers -&gt; ALU -&gt; output register -&gt; registers or memory
</code></pre></div></div>
<p>How do instructions get executed? \(\textbf{Fetch-decode-execute}\) cycle. Instructions get executed as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Fetch the next instruction from memory into the instruction register.
2. Change the program counter to point to the following instruction.
3. Determine the type of instruction just fetched.
4. If the instruction uses a word in memory, determine where it is.
5. Fetch the word, if needed, into a CPU register.
6. Execute the instruction.
7. Go to step 1 to begin executing the following instruction
</code></pre></div></div>

<h4 id="clock-cycles">Clock cycles</h4>

<p>A clock is a circuit that emits pulses with a precise pulse width and a time interval between consecutive pulses. The time interval between two consecutive pulses is called the clock cycle time; pulse frequencies range from 100Mhz and 4Ghz corresponding to 10 nsec to 250 psec. This pulse frequency falls in the range of 4ghz. A lot of events happen during a given clock cycle; for example, the program counter is  loaded with an instruction address every clock cycle, the registers get updated every clock cycle and memory locations get written when a <code class="language-plaintext highlighter-rouge">mov</code>, <code class="language-plaintext highlighter-rouge">push</code> and <code class="language-plaintext highlighter-rouge">call</code> instruction get executed. The control of  the memory and registers by the clock cycle is  what allows the instructions to get executed in a sequence.</p>

<p>But in practice there’s instruction parallelism.</p>

<h4 id="instruction-parallelism">Instruction parallelism</h4>

<p>\(\textbf{Instruction level parallelism}\) is a process whereby the processor executes more instructions per second; it does this by implementing pipelining whereby more stuff gets done in less processor cycles.</p>

<p>Instruction level parallelism is exploited in compilers.</p>

<p>The main idea of instruction level parallelism is to pre-fetch instructions from memory and put them in a set of special registers called the pre-fetch buffer and as a result of this the processor would not have to read from memory which takes hundreds of cycles. In a pipeline, execution is divided into stages in which each stage is carried out by a different type of hardware in parallel.</p>

<p>Suppose you divide the execution into five stages.</p>

<p>Stage 1 fetches instructions from memory and are stored in the prefetch buffer. Stage 2  determines the type and determines which operands it needs. Stage 3 fetches the operands; stage 4 carries out the execution and stage 5 writes the output to a register. Since these stages can be carried out in parallel it is fast; for example during the first clock cycle  Stage 1 does its job; during the second clock cycle Stage 2 does its job but also Stage 1 does its job for the next instruction. And during the third clock cycle Stage 3 does its job for the first instruction, stage 2 does its job for the second instruction, and stage 1 does its job for the third instruction and so on. Now, suppose that each clock cycle takes 2ns to complete; so one instruction takes 10ns to get processed by each stage so there 500 million instructions per second get executed.</p>

<h3 id="conclusion">Conclusion</h3>
<p>As you can see there is a whole world as to how computers work. Getting to know architecture is a very interesting thing. Obviously, I have a lot to learn and what I wrote above is just the very basics.</p>

<p>Well, I have briefly discussed the cpu architecture and have exposed the x86 architecture through some basic high level programs. Hopefully, you enjoyed it.</p>]]></content><author><name>Job Hernandez Lara</name></author><category term="cpu-architecture" /><category term="x86-64" /><category term="computer-science" /></entry><entry><title type="html">How do operating systems work?</title><link href="http://localhost:4000/2023/10/29/How-do-Operating-Systems-work.html" rel="alternate" type="text/html" title="How do operating systems work?" /><published>2023-10-29T00:00:00-07:00</published><updated>2023-10-29T00:00:00-07:00</updated><id>http://localhost:4000/2023/10/29/How-do-Operating-Systems-work</id><content type="html" xml:base="http://localhost:4000/2023/10/29/How-do-Operating-Systems-work.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#what-is-an-operating-system" id="markdown-toc-what-is-an-operating-system">What is an operating system?</a>    <ul>
      <li><a href="#processes-and-threads" id="markdown-toc-processes-and-threads">Processes and threads</a></li>
      <li><a href="#cpu-scheduling" id="markdown-toc-cpu-scheduling">CPU Scheduling</a></li>
      <li><a href="#interprocess-communication" id="markdown-toc-interprocess-communication">Interprocess communication</a></li>
      <li><a href="#memory-management" id="markdown-toc-memory-management">Memory Management</a></li>
      <li><a href="#traps-interrupts-and-drivers" id="markdown-toc-traps-interrupts-and-drivers">Traps, interrupts, and drivers</a></li>
      <li><a href="#locking" id="markdown-toc-locking">Locking</a></li>
      <li><a href="#deadlock" id="markdown-toc-deadlock">Deadlock</a></li>
      <li><a href="#file-system" id="markdown-toc-file-system">File System</a>        <ul>
          <li><a href="#buffer-cache" id="markdown-toc-buffer-cache">Buffer Cache</a></li>
          <li><a href="#logging" id="markdown-toc-logging">Logging</a></li>
          <li><a href="#block-allocator" id="markdown-toc-block-allocator">Block Allocator</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
</ul>

<h3 id="introduction">Introduction</h3>

<p>Last two years or so I have been on a journey to study computer science fundamentals. Over the course of the last two years I have studied algorithms, distributed systems and compilers among other topics but operating systems is one of my favorite topics.</p>

<p>In what follows I will explain how an operating system works based on my studies of the MIT <a href="https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev3.pdf">xv6</a> and “Operating System Concepts”.</p>

<p>Obviously, I am not an expert. But I enjoy this topic a lot and wrote this to learn.</p>

<h3 id="what-is-an-operating-system">What is an operating system?</h3>

<p>The operating system provides resources to the apps that you use. These resources include memory, CPU time, files, and I/O. Since a process is an abstraction for a running program then we can say the process is the main character in an OS. The OS allocates CPU time, memory, files and I/O to processes.</p>

<p>The OS provides services to user programs through an interface. What is the Unix philosophy for designing interfaces? The Unix interface, i.e., system calls, is simple and narrow which allows ease of implementation. Unix has a simple and narrow interface but this set of system calls allow combinations to make more complex and general functionality.</p>

<p>xv6 and modern operating systems such as MacOS and Linux offers <em>time sharing</em> transparently switches the CPUs among the processes.</p>

<h4 id="processes-and-threads">Processes and threads</h4>

<p>A process needs resources – namely, CPU time, memory, files, and I/O devices. These resources are allocated to the process while it is running. How is the process concept related to web programming? Suppose there is a process running on the web browser and it is trying to send a request to the server. The process will take an URL as an input and it will then carry out the appropriate instructions and system calls to display the response (web page).</p>

<p>A process is an abstraction for a program in execution; each process has its own address space and its memory is laid out as follows: text section, data section, heap and stack. The text section consists of the executable code, the data section consists of global variables, the stack consists of data storage associated with invocations of functions such as parameters, return address, and the heap is associated with dynamically memory storage such as when you allocate memory in C with malloc; for example, in an x86-64 if you were to loop over an array and print each element you would divide the program into <em>.data</em> and <em>.text</em> sections. In the <em>.data</em> section you would declare and initialize the array and in the <em>.text</em> section you would have the instructions. But to clarify, a program by itself is not a process; a program is a passive entity. In contrast a process is an active entity consisting of a program counter that points to the subsequent instruction and consisting of the contents of the registers. A thread is the execution control center of a given process. “A thread represents the basic unit of CPU utilization.” There could be multiple threads per process. A <em>thread</em> has its own stack but shares the same address space with other threads. This makes sense because threads need to be aware of the same program. Ultimately, user level threads need to be mapped to kernel threads for the CPU to execute. There are several models of this, namely, many-to-one, one-to-one and many-to-many. As you might expect, when the model is many-to-one, many user threads get mapped to one kernel thread.</p>

<h4 id="cpu-scheduling">CPU Scheduling</h4>

<p>The kernel time shares processes - it switches the CPUs among the processes. What happens when a process is not executing? The kernel saves the process’ CPU registers and restores them once the process runs again. Multiplexing means switching a CPU from one process to another. Context switching means multiplexing. Why is scheduling important? Scheduling is important because operating systems run with more processes than the computer has CPUs. How does scheduling happen? In response to system calls or interrupts the kernel switches from one process to another by the following way. First, there’s a user-kernel transition to the old process’ kernel thread, a context switch to the current CPU’s scheduler thread, a context switch to a new (the one the kernel is switching to) process kernel thread and a trap return to the user level processes the kernel was switching to. Each CPU has its own scheduler thread which makes sense since when switching from user process A to user process B there is a transition to the process’ A kernel thread via a system call, a context switch to the scheduler thread, and a context switch to process’ B kernel thread. So, this means that scheduling involves alternating from thread to thread. And remember a thread is what executes the given process’ instructions. Threads share memory with other threads but have their own stack. What happens when a process gives up the CPU? The process’ kernel thread calls switch to save its own context and return the scheduler context. I think this is why the kernel switches from the old user process kernel thread to the scheduler thread. Switching from one thread to a new one involves saving the registers on the old thread and restoring the registers of the new one. A scheduler is essentially a thread in the CPU. There is one scheduler thread per CPU. Each schedule thread has the scheduler function.</p>

<p>A timer interrupt drives context switching, i.e., the switch from one process to another process.</p>

<p>The kernel maintains a page table for each process. Page tables enable the kernel to isolate the different process’ address space and multiplex them into a single memory system. When the kernel context switches it also switches page tables. The page table for each given process describes the user address space; moreover, the kernel provides a page table that describes the kernel address space.</p>

<p>The CPU scheduler is responsible for deciding which processes to allocate to the CPU. There are several algorithms for CPU scheduling; the simplest is a first come, first served algorithm in which the first process that requests the CPU gets allocated to the CPU; this is accomplished with the FIFO queue data structure; the first process that enters the queue it is the first out of the queue. What is tremendously amazing about scheduling is that the user does not notice when the CPU switches from one process to another process. So, it is interesting to think how one would build this. Why does the cpu scheduler exist? In most operating systems there will be more processes than there are CPUs so there needs to be a way for the CPUs to work on all of these programs.</p>

<h4 id="interprocess-communication">Interprocess communication</h4>

<p>Often processes need to communicate with other processes because they may need to access main memory. This can lead to race conditions. A race condition happens when two or more processes are sharing data (from main memory for instance) and the final result depends on the order of the processes. If one process runs before another process it may change the result because the order is off. How do we avoid race conditions? The answer is mutual exclusion; mutual exclusion dictates that when two or more processes share memory the processes that are not using the shared data are excluded from accessing the data. Mutual exclusion is achieved by semaphores, mutexes. A semaphore is initialized to the number of resources; when a process wants to use a resource it calls the wait() function thereby decrementing the count. When the process releases a resource it performs a signal() thereby incrementing the count. When the count is 0 processes are blocked until it increments again. When a process modifies a semaphore value another process cannot access the same semaphore value – i.e., cannot access the same resource.</p>

<h4 id="memory-management">Memory Management</h4>

<p>The job of the memory manager is to keep track of the parts of memory that are being used, to allocate memory to processes and to deallocate memory when the processes are done with it. How does the memory manager accomplish this? It does this through an abstraction mechanism known as virtual memory. As discussed above a process is an abstraction for a program; likewise, a virtual address space is an abstraction of main memory – it gives the illusion that each process has its own main memory. The set of addresses that a process can use to address memory is called the virtual address space. The basic idea behind main memory is that a process has its own virtual address space which is laid out as pages where a page is a contiguous range of memory addresses. The given processor’s instructions manipulate virtual addresses; for example when you write, in assembly, <code class="language-plaintext highlighter-rouge">movq immediate, address1</code>, the operating system translates the virtual address <code class="language-plaintext highlighter-rouge">address1</code> into a physical address. The operating system maps virtual addresses to physical addresses using <em>page tables</em>.</p>
<blockquote>
  <p>… virtual memory is not a physical object, but refers to the collection of abstractions and mechanisms the kernel provides to manage physical memory and virtual addresses.</p>
</blockquote>

<p>And it is also important to note that the given operating system maintains one page table per process; and the root of the given page table is written to a register before the page table gets processed. Consider the <em>xv6</em> Unix kernel programmed by MIT. <em>xv6</em> is tailored to the Sv39 RISC-V processor - the top 39 bits of a 64 bit virtual address space are used for this; in the Sv39 processor a page table is logically an array of \(2^{27}\) page table entries (PTEs). Each PTE has a 44 bit physical page number. The paging hardware translates the virtual address by using the top 27 bits of the 39 bits to index the page table to find the PTE. The paging hardware also makes 56 bit physical addresses whose top 44  bits come from the physical page number of the page table entry and whose bottom 12 bits come from the virtual address. The page table is stored in physical memory as a tree whose root node consists of a 4096-byte page table. In turn, this page contains 512 PTEs that contain the physical addresses of the page table pages of the next level of the tree and in turn these pages contain the addresses of the page table pages of the final level of the tree. The OS uses the top level 9 bits of the 27 bits to select a PTE from the root page table page and further, it uses the middle 9 bits to select the PTEs from the middle level of the tree and finally it uses the bottom 9 bits to select the PTEs from the final page table page in the final level of the tree. <em>How does the kernel allocate and free memory?</em>The kernel must allocate and free memory at run-time for page tables, user memory, kernel stacks, etc. It allocates and frees 4096 byte pages at a time. The kernel maintains a linked list of free pages. Allocation of a page consists of removing a page from the list and freeing a page consists of adding a page to the list.</p>

<h4 id="traps-interrupts-and-drivers">Traps, interrupts, and drivers</h4>

<p>What goes on with the CPU when a given process is running? The CPU executes the processor loop, namely, read an instruction, advance the program counter, execute the instruction, repeat. Often, however, control must transition from user programs to kernel instead of executing the next instruction. This happens when a user program does something illegal such as dividing by 0, trying to access a page table entry for which there is no virtual address.</p>

<p>An <em>exception</em> triggers an interrupt when there’s an illegal program action. An <em>interrupt</em> is a signal that tells the OS that it needs to pay attention to it; for example, a clock chip may generate an interrupt every 100 msec to allow the kernel implement time sharing. The kernel is responsible for handling the interrupts. When designing an OS/kernel one needs to be aware of how the underlying processor handles system calls, interrupts and exceptions; for example, on the x86 a program triggers a system call by generating an interrupt using the <em>int</em> instruction. Exceptions generate an interrupt too.</p>

<p>How do <em>interrupts</em> work? As mentioned above an interrupt stops the processor loop; once the processor loop stops the interrupt executes a new sequence called an <em>interrupt handler</em>. And of course before starting this new sequence, the processor saves its registers so it can resume after the OS has returned from the interrupt. So, this means that the transition from the processor loop to the interrupt handler involves going from user mode and kernel mode.</p>

<p>Interrupts in UNIX terms are known as <em>traps</em>.</p>

<p>How does xv6 and thus Unix invoke a system call? To invoke a system call a program indexes the interrupt descriptor table (IDT) by invoking the <em>int</em>  instruction where n is the index of the IDT.</p>

<h4 id="locking">Locking</h4>

<p>xv6 runs on multiprocessors; this means that multiple CPUs are executing instructions independently and since there is only one physical address space and shared data structures, xv6 needs a mechanism to keep them from interfering with one another. This is what <em>locking</em> accomplishes. A lock achieves mutual exclusion which makes sure that one CPU at a time can hold the lock. In turn, this allows careful treatment of the data structures.</p>

<p>Since there are multiple processors, for a given line of code, multiple processors can execute the line which will result in problems. Locking allows multiple processors to execute the line of code without introducing unwanted changes to the data structure.</p>

<p>The reason why we need locks is to prevent <em>race conditions</em>. Race conditions result from the ordering of execution of two or more processors that invalidates a data structure. A processor S may be operating on A but then processor T may work on A which will result in processor S working on a modified version of A, let’s call it B.</p>

<h4 id="deadlock">Deadlock</h4>

<p>Deadlocks involve the ordering of locks. Suppose a code path require to take out several locks. When this happens it is important that all code paths acquire the locks in the same order. Suppose there’s to code paths and both paths need locks A and B. If code path 1 acquires locks in the order A, B and the other path acquires locks in the order B, A. This can result in a deadlock because when path 1 acquires lock A, path 2 will acquire B. As a result path 1 will wait for B and path 2 will wait for A. Both path are waiting. In other words, a deadlock happens when two processors hold the lock that each of them needs.</p>

<h4 id="file-system">File System</h4>
<p>The file system exists to organize and store data; it is an abstraction of disk.</p>

<h5 id="buffer-cache">Buffer Cache</h5>

<p>The buffer cache has two jobs: 1) ensures that only one copy of a disk block is in memory; 2) cache popular blocks so they do not have to be re-read from the slow disk. The buffer cache has an interface; in xv6 the interface is <code class="language-plaintext highlighter-rouge">bread</code> and <code class="language-plaintext highlighter-rouge">bwrite</code>. The former gets a buffer consisting of a block that can be read or modified and the latter writes a modified block to disk. In other words, there is a transition between memory and disk. A block can first be in memory and it can be read and modified in memory. <code class="language-plaintext highlighter-rouge">bread</code> gets a copy of such block. <code class="language-plaintext highlighter-rouge">bwrite</code> writes this modified block to disk. So, there seems to be a transition between memory and disk. How does the buffer cache synchronize access to each block? It only allows at most one kernel thread to reference to the block’s buffer. While one kernel thread is referring to a block buffer other threads will have to wait until the thread releases the buffer block.</p>

<h5 id="logging">Logging</h5>

<p>Logging solves the problem of crashes during file system operations.</p>

<h5 id="block-allocator">Block Allocator</h5>
<p>File content and directory content are stored in disk blocks which are allocated from a free pool. So, the blocks that the buffer cache synchronizes contain file and directory content. The block allocator consists of a bitmap on the disk. Each bit in this bitmap corresponds to one block. If the bit is 0 then the block is free; otherwise, the block has content. The block allocator has two functions: <code class="language-plaintext highlighter-rouge">balloc</code> and <code class="language-plaintext highlighter-rouge">bfree</code> which allocates a block and frees a block respectively.</p>

<h3 id="conclusion">Conclusion</h3>
<p>Above I have tried to explain what an operating system is. Operating systems are fascinating systems. It is amazing that anything at all works in operating systems. You should pick up a textbook and study this topic. Enjoy.</p>]]></content><author><name>Job Hernandez Lara</name></author><category term="x86-64" /><category term="operating-systems" /><category term="computer-science" /></entry><entry><title type="html">Power of Lisp macros</title><link href="http://localhost:4000/2023/10/25/power-of-lisp-macros.html" rel="alternate" type="text/html" title="Power of Lisp macros" /><published>2023-10-25T00:00:00-07:00</published><updated>2023-10-25T00:00:00-07:00</updated><id>http://localhost:4000/2023/10/25/power-of-lisp-macros</id><content type="html" xml:base="http://localhost:4000/2023/10/25/power-of-lisp-macros.html"><![CDATA[<h3 id="introduction">Introduction</h3>

<p>I find it hard to admit but I spent on average around 2 hours a day programming in Lisp for about 3 years and never touched macros. But fortunately by contributing to open source and seeing how really good programmers program I was able to pick up some macro skills.</p>

<p>As a result, I have more appreciation for Lisp and kind of see how in other languages you end up repeating yourself due to lack of syntactic abstraction; moreover, I have seen how macros enable you to build languages and extend the Lisp language itself.</p>

<p>This is all important because, as the SICP authors claimed, software engineering is about controlling complexity. Using macros allows you to control complexity because by using macros your systems are easier to maintain and by using macros for building DSLs and extending Lisp itself you end up increasing the expressiveness of Lisp.</p>

<p>In what follows I will explain how macros are indeed useful and lead to better systems.</p>

<p>Definitely, I am not an expert but these are my observations from contributing to Coalton and conversing with the creator of Coalton.</p>

<h3 id="macros-allow-you-to-get-more-done-with-less">Macros allow you to get more done with less</h3>

<p>One of the reasons why Lisp macros are powerful is because macros enable syntactic abstraction. Syntactic abstraction leads to shorter code and more modular code and  moreover it leads to code without repeating patterns.</p>

<p>Consider building a vector library. Suppose you are trying to implement different types such as single float and double float and so on.</p>

<p>In Common Lisp you can write the pattern of addition once and I apply it \(n\) times where \(N\) is the number of types you are implementing.</p>

<p>Here is how I would write it:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">addition-handler</span> <span class="p">(</span><span class="k">type</span> <span class="nv">fn-name</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">defun</span> <span class="o">,</span><span class="nv">fn-name</span> <span class="p">(</span><span class="nv">vec</span> <span class="nv">vec2</span><span class="p">)</span>
 	<span class="p">(</span><span class="k">progn</span> <span class="p">(</span><span class="k">setq</span> <span class="nv">vec3</span> <span class="p">(</span><span class="nb">make-array</span> <span class="o">,</span><span class="p">(</span><span class="nb">length</span> <span class="nv">vec</span><span class="p">)</span> <span class="ss">:element-type</span> <span class="ss">',type</span><span class="p">))</span>
    	<span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="o">,</span><span class="p">(</span><span class="nb">length</span> <span class="nv">vec</span><span class="p">))</span>
      	<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">vec3</span> <span class="nv">i</span><span class="p">)</span>
   	 	<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">vec</span> <span class="nv">i</span><span class="p">)</span>
   	    	    <span class="p">(</span><span class="nb">aref</span> <span class="nv">vec2</span> <span class="nv">i</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nv">addition-handler</span> <span class="kt">single-float</span> <span class="nv">addition-vector-single-float</span><span class="p">)</span>
<span class="p">(</span><span class="nv">addition-handler</span> <span class="kt">double-float</span> <span class="nv">addition-vector-double-float</span><span class="p">)</span>
</code></pre></div></div>

<p>You can continue this pattern and implement more vector operations and more types.</p>

<p>So, in Lisp you can get more done with less code. In turn, this leads to smaller systems due to the abstraction and since smaller systems are easier to make sense of the ease of maintenance increases.</p>

<h3 id="macros-allow-you-to-build-dsls">Macros allow you to build DSLs</h3>

<p>In SICP you learn that DSLs are the ultimate abstraction. Software engineering is about controlling complexity. As we have seen previously macros allow you to control complexity because macros lead to more abstracted systems.</p>

<p>It turns out that the power of macros is about building languages. As Robert, the creator of Coalton and an state of the art quantum computing compiler Quilc said:</p>

<blockquote>
  <p>The real power of macros is when they’re in the hands of compiler writers and language designers.</p>
</blockquote>

<p>The idea of building DSLs with macros is closely tied to the idea that software systems should be evolvable and adaptable; for example, in the book “Software Design for Flexibility”, Sussman and Hanson claimed that systems need to be evolvable. According to them, systems should be designed in such a way that they adapt and grow as requirements change.</p>

<blockquote>
  <p>The best systems are evolvable: they can be adapted to new situations with only minor modifications.</p>
</blockquote>

<p>When adding a new feature one should be able to add to the system instead of modifying the codebase.</p>

<p>Well Lisp can be seen as an evolvable system. With macros you can adapt the language to new situations and can extend the language with new constructs without modifying the Lisp compiler.</p>

<p>You can see Lisp as an assembly of tiny domain specific languages.</p>

<p>Lisp has a tiny core and the rest of the language can be built by writing macros. As Alan Kay said:</p>

<blockquote>
  <p>Yes, that was the big revelation to me when I was in graduate school—when I finally understood that the half page of code on the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These were “Maxwell’s Equations of Software!” This is the whole world of programming in a few lines that I can put my hand over.</p>
</blockquote>

<p>So, as I said Lisp is an evolvable system because it has macros; for example, suppose your favorite language doesn’t have list comprehensions. How would you add this construct to your language? The only way you can do this is by modifying the compiler. As a result, your favorite language is not as evolvable as it could be.</p>

<p>In a conversation I had on Twitter with Robert Smith, he demonstrated the power of macros by showing me how a language for list comprehensions could be implemented.</p>

<p>What follows is a summary of his message.</p>

<p>Suppose you want to express this in your language:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[(x, y) for x in range(5) for y = 2*x when isEven(x)] 
</code></pre></div></div>

<p>How would you add list comprehensions to your favorite language? You cannot.</p>

<p>But in Lisp you can write a macro that allows you to express this.</p>

<p>For example, a macro for list comprehensions is a tiny DSL.</p>

<p>You might say that Python can be used as this because of macros but as Robert Smith says:</p>

<blockquote>
  <p>(1) Python macros don’t really exist as a defined part of the language, (2) python has no concept of “macroexpansion time”, (3) being able to manipulate ASTs and source code is not the same as having a macro facility built in to the language, even if you can accomplish similar tasks in theory. I would say that python allows metaprogramming (in a very bizarre and difficult way), but NOT that it supports macros. The  language is definitely not homoiconic, which is a key ingredient in making macros facile.</p>
</blockquote>

<p>I was able to see the power of macros thanks to Robert Smith. He explained this to me by the following implementation of the the loop comprehension DSL:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;;; A list comprehension will be defined as:</span>
<span class="c1">;;;</span>
<span class="c1">;;;    (comp &amp;lt;expr&amp;gt; &amp;lt;clause&amp;gt;*)</span>
<span class="c1">;;;</span>
<span class="c1">;;; where &amp;lt;expr&amp;gt; is any Lisp expression, and &amp;lt;clause&amp;gt; can be:</span>
<span class="c1">;;;</span>
<span class="c1">;;;    &amp;lt;clause&amp;gt; := (for &amp;lt;var&amp;gt; in &amp;lt;expr&amp;gt;)</span>
<span class="c1">;;;              | (for &amp;lt;var&amp;gt; = &amp;lt;expr&amp;gt;)</span>
<span class="c1">;;;              | (for &amp;lt;var&amp;gt; from &amp;lt;expr&amp;gt; to &amp;lt;expr&amp;gt;)</span>
<span class="c1">;;;              | (when &amp;lt;expr&amp;gt;)</span>
<span class="c1">;;;</span>
<span class="c1">;;; For example,</span>
<span class="c1">;;;</span>
<span class="c1">;;;    (comp (list x y) (for x from 1 to 100) (for y = (* x x)) (when (evenp y)))</span>
<span class="c1">;;;</span>
<span class="c1">;;; would generate a list of numbers and their squares, only when the</span>
<span class="c1">;;; square is even.</span>

<span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nv">compile-comp</span> <span class="o">'</span><span class="p">(</span><span class="nv">comp</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">y</span> <span class="nb">=</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">evenp</span> <span class="nv">y</span><span class="p">))))</span>

 <span class="p">(</span><span class="nv">LET</span> <span class="p">((</span><span class="ss">#:RESULT1639</span> <span class="nv">NIL</span><span class="p">))</span> <span class="p">(</span><span class="nv">LOOP</span> <span class="ss">:FOR</span> <span class="nv">X</span> <span class="ss">:FROM</span> <span class="mi">1</span> <span class="ss">:TO</span> <span class="mi">100</span> <span class="ss">:DO</span> <span class="p">(</span><span class="nv">LET</span> <span class="p">((</span><span class="nv">Y</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">X</span> <span class="nv">X</span><span class="p">)))</span> <span class="p">(</span><span class="nv">WHEN</span> <span class="p">(</span><span class="nv">EVENP</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">(</span><span class="nv">PUSH</span> <span class="p">(</span><span class="nv">LIST</span> <span class="nv">X</span> <span class="nv">Y</span><span class="p">)</span> <span class="ss">#:RESULT1639</span><span class="p">))))</span> <span class="p">(</span><span class="nv">NREVERSE</span> <span class="ss">#:RESULT1639</span><span class="p">))</span>

<span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nv">compile-comp</span> <span class="o">'</span><span class="p">(</span><span class="nv">comp</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">y</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">10</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">LET</span> <span class="p">((</span><span class="ss">#:RESULT1640</span> <span class="nv">NIL</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">LOOP</span> <span class="ss">:FOR</span> <span class="nv">X</span> <span class="ss">:FROM</span> <span class="mi">1</span> <span class="ss">:TO</span> <span class="mi">10</span>
    	<span class="ss">:DO</span> <span class="p">(</span><span class="nv">LOOP</span> <span class="ss">:FOR</span> <span class="nv">Y</span> <span class="ss">:FROM</span> <span class="mi">1</span> <span class="ss">:TO</span> <span class="mi">10</span>
              	<span class="ss">:DO</span> <span class="p">(</span><span class="nv">PUSH</span> <span class="nv">X</span> <span class="ss">#:RESULT1640</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">NREVERSE</span> <span class="ss">#:RESULT1640</span><span class="p">))</span>


<span class="p">(</span><span class="nb">defun</span> <span class="nv">for-in-clause?</span> <span class="p">(</span><span class="nv">form</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">form</span><span class="p">))</span>
   	<span class="p">(</span><span class="nb">string=</span> <span class="s">"FOR"</span> <span class="p">(</span><span class="nb">first</span> <span class="nv">form</span><span class="p">))</span>
   	<span class="p">(</span><span class="nb">string=</span> <span class="s">"IN"</span> <span class="p">(</span><span class="nb">third</span> <span class="nv">form</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">for-=-clause?</span> <span class="p">(</span><span class="nv">form</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">form</span><span class="p">))</span>
   	<span class="p">(</span><span class="nb">string=</span> <span class="s">"FOR"</span> <span class="p">(</span><span class="nb">first</span> <span class="nv">form</span><span class="p">))</span>
   	<span class="p">(</span><span class="nb">string=</span> <span class="s">"="</span> <span class="p">(</span><span class="nb">third</span> <span class="nv">form</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">for-range-clause?</span> <span class="p">(</span><span class="nv">form</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">6</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">form</span><span class="p">))</span>
   	<span class="p">(</span><span class="nb">string=</span> <span class="s">"FOR"</span> <span class="p">(</span><span class="nb">first</span> <span class="nv">form</span><span class="p">))</span>
   	<span class="p">(</span><span class="nb">string=</span> <span class="s">"FROM"</span> <span class="p">(</span><span class="nb">third</span> <span class="nv">form</span><span class="p">))</span>
   	<span class="p">(</span><span class="nb">string=</span> <span class="s">"TO"</span> <span class="p">(</span><span class="nb">fifth</span> <span class="nv">form</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">when-clause?</span> <span class="p">(</span><span class="nv">form</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">form</span><span class="p">))</span>
   	<span class="p">(</span><span class="nb">string=</span> <span class="s">"WHEN"</span> <span class="p">(</span><span class="nb">first</span> <span class="nv">form</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">list-comprehension-form?</span> <span class="p">(</span><span class="nv">form</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">form</span><span class="p">))</span>
   	<span class="p">(</span><span class="nb">string=</span> <span class="s">"COMP"</span> <span class="p">(</span><span class="nb">first</span> <span class="nv">form</span><span class="p">))))</span>


<span class="p">(</span><span class="nb">defun</span> <span class="nv">compile-clause</span> <span class="p">(</span><span class="nv">build-expr</span> <span class="nv">clause</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span>
	<span class="p">((</span><span class="nv">for-in-clause?</span> <span class="nv">clause</span><span class="p">)</span>
 	<span class="o">`</span><span class="p">(</span><span class="nb">loop</span> <span class="ss">:for</span> <span class="o">,</span><span class="p">(</span><span class="nb">second</span> <span class="nv">clause</span><span class="p">)</span> <span class="ss">:in</span> <span class="o">,</span><span class="p">(</span><span class="nb">fourth</span> <span class="nv">clause</span><span class="p">)</span>
        	<span class="ss">:do</span> <span class="o">,</span><span class="nv">build-expr</span><span class="p">))</span>
	<span class="p">((</span><span class="nv">for-=-clause?</span> <span class="nv">clause</span><span class="p">)</span>
 	<span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="p">(</span><span class="nb">second</span> <span class="nv">clause</span><span class="p">)</span> <span class="o">,</span><span class="p">(</span><span class="nb">fourth</span> <span class="nv">clause</span><span class="p">)))</span>
    	<span class="o">,</span><span class="nv">build-expr</span><span class="p">))</span>
	<span class="p">((</span><span class="nv">for-range-clause?</span> <span class="nv">clause</span><span class="p">)</span>
 	<span class="o">`</span><span class="p">(</span><span class="nb">loop</span> <span class="ss">:for</span> <span class="o">,</span><span class="p">(</span><span class="nb">second</span> <span class="nv">clause</span><span class="p">)</span> <span class="ss">:from</span> <span class="o">,</span><span class="p">(</span><span class="nb">fourth</span> <span class="nv">clause</span><span class="p">)</span> <span class="ss">:to</span> <span class="o">,</span><span class="p">(</span><span class="nb">sixth</span> <span class="nv">clause</span><span class="p">)</span>
        	<span class="ss">:do</span> <span class="o">,</span><span class="nv">build-expr</span><span class="p">))</span>
	<span class="p">((</span><span class="nv">when-clause?</span> <span class="nv">clause</span><span class="p">)</span>
 	<span class="o">`</span><span class="p">(</span><span class="nb">when</span> <span class="o">,</span><span class="p">(</span><span class="nb">second</span> <span class="nv">clause</span><span class="p">)</span>
    	<span class="o">,</span><span class="nv">build-expr</span><span class="p">))</span>
	<span class="p">(</span><span class="no">t</span>
 	<span class="p">(</span><span class="nb">error</span> <span class="s">"Invalid clause: ~S"</span> <span class="nv">clause</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">compile-clauses</span> <span class="p">(</span><span class="nv">build-expr</span> <span class="nv">clauses</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">clauses</span><span class="p">)</span>
  	<span class="nv">build-expr</span>
  	<span class="p">(</span><span class="nv">compile-clauses</span>
   	<span class="p">(</span><span class="nv">compile-clause</span> <span class="nv">build-expr</span> <span class="p">(</span><span class="nb">first</span> <span class="nv">clauses</span><span class="p">))</span>
   	<span class="p">(</span><span class="nb">rest</span> <span class="nv">clauses</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">compile-comp</span> <span class="p">(</span><span class="nv">form</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nv">list-comprehension-form?</span> <span class="nv">form</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">clauses</span>	<span class="p">(</span><span class="nb">nthcdr</span> <span class="mi">2</span> <span class="nv">form</span><span class="p">))</span>
     	<span class="p">(</span><span class="nv">result</span> 	<span class="p">(</span><span class="nb">gensym</span> <span class="s">"RESULT"</span><span class="p">))</span>
     	<span class="p">(</span><span class="nv">build-expr</span> <span class="o">`</span><span class="p">(</span><span class="nb">push</span> <span class="o">,</span><span class="p">(</span><span class="nb">second</span> <span class="nv">form</span><span class="p">)</span> <span class="o">,</span><span class="nv">result</span><span class="p">)))</span>
	<span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">result</span> <span class="no">nil</span><span class="p">))</span>
   	<span class="o">,</span><span class="p">(</span><span class="nv">compile-clauses</span> <span class="nv">build-expr</span> <span class="p">(</span><span class="nb">reverse</span> <span class="nv">clauses</span><span class="p">))</span>
   	<span class="p">(</span><span class="nb">nreverse</span> <span class="o">,</span><span class="nv">result</span><span class="p">))))</span>
</code></pre></div></div>

<p>Here is the interaction in the REPL:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">*</span> <span class="p">(</span><span class="nb">defmacro</span> <span class="nv">comp</span> <span class="p">(</span><span class="nv">expr</span> <span class="k">&amp;rest</span> <span class="nv">clauses</span><span class="p">)</span> <span class="p">(</span><span class="nv">compile-comp</span> <span class="o">`</span><span class="p">(</span><span class="nv">comp</span> <span class="o">,</span><span class="nv">expr</span> <span class="o">,@</span><span class="nv">clauses</span><span class="p">)))</span> 

<span class="nb">*</span> <span class="p">(</span><span class="nv">comp</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">10</span><span class="p">))</span> 
  <span class="p">(</span><span class="mi">1</span> <span class="mi">4</span> <span class="mi">9</span> <span class="mi">16</span> <span class="mi">25</span> <span class="mi">36</span> <span class="mi">49</span> <span class="mi">64</span> <span class="mi">81</span> <span class="mi">100</span><span class="p">)</span> 

<span class="nb">*</span> <span class="p">(</span><span class="nv">comp</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">y</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">x</span> <span class="nv">in</span> <span class="p">(</span><span class="nv">comp</span> <span class="p">(</span><span class="nb">sin</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">evenp</span> <span class="nv">y</span><span class="p">)))))</span> 
<span class="p">(</span><span class="mf">0.82682174</span> <span class="mf">0.57275003</span> <span class="mf">0.07807302</span> <span class="mf">0.97882974</span> <span class="mf">0.295959</span><span class="p">)</span> 

<span class="nb">*</span> <span class="p">(</span><span class="nv">comp</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">y</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span> 
<span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="mi">8</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">8</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="mi">9</span> <span class="mi">10</span><span class="p">))</span>
</code></pre></div></div>

<p>As you can see you can extend Lisp, which does not support list comprehensions, with the ability to express comprehensions. This is indeed the power of macros.</p>

<h3 id="conclusion">Conclusion</h3>

<p>So, there you go. Based on my observations and conversations I have had I have tried to show the power of macros. Firstly, I showed how you can do more with less code by using macros which in turn leads to systems without repeating patterns. If you consider that Lisp also has higher order functions you can see how Lisp is a great language to build modular code. In addition, I shared how macros can help the programmer extend the Lisp language itself which is the ultimate way to conquer complexity.</p>]]></content><author><name>Job Hernandez Lara</name></author><category term="lisp" /><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>